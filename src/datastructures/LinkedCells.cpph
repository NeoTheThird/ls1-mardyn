
#include "molecules/potforce.h"
#include "datastructures/handlerInterfaces/ParticlePairsHandler.h"
#include "Cell.h"

#ifdef GRANDCANONICAL
#include "parallel/DomainDecompBase.h"
#include "ensemble/GrandCanonical.h"
#endif

#include <cmath>
#include <iostream>
using namespace std;

template<class ParticleType>
utils::Log datastructures::LinkedCells<ParticleType>::_log("LinkedCells");

template<class ParticleType>
datastructures::LinkedCells<ParticleType>::LinkedCells(double bBoxMin[3], double bBoxMax[3], double cutoffRadius, double LJCutoffRadius,
#ifdef COMPLEX_POTENTIAL_SET
                double tersoffCutoffRadius,
#endif
                double cellsInCutoffRadius, datastructures::ParticlePairsHandler<ParticleType>& partPairsHandler):
                datastructures::ParticleContainer<ParticleType>(partPairsHandler, bBoxMin, bBoxMax){
               
  int numberOfCells = 1;
  _cutoffRadius = cutoffRadius;
  _LJCutoffRadius = LJCutoffRadius;
#ifdef COMPLEX_POTENTIAL_SET
  this->_tersoffCutoffRadius = tersoffCutoffRadius;
#endif
  _cellsInCutoffRadius = cellsInCutoffRadius;
  cout << "bboxmin: " << this->_boundingBoxMin[0] << " / " << this->_boundingBoxMin[1] << " / " << this->_boundingBoxMin[2] << endl;
  cout << "bboxmax: " << this->_boundingBoxMax[0] << " / " << this->_boundingBoxMax[1] << " / " << this->_boundingBoxMax[2] << endl;
  cout << "rc: " << _cutoffRadius << endl;
  cout << "_cellsInCutoffRadius: " << _cellsInCutoffRadius << endl;
  for(int dim=0; dim<3; dim++){
    _haloWidthInNumCells[dim] = (int) ceil(cellsInCutoffRadius);
    _cellsPerDimension[dim] = (int) floor((this->_boundingBoxMax[dim]-this->_boundingBoxMin[dim])/(cutoffRadius/cellsInCutoffRadius))
                                   + 2 * _haloWidthInNumCells[dim];
    // in each dimension at least one layer of (inner+boundary) cells necessary
    if(_cellsPerDimension[dim] == 2 * _haloWidthInNumCells[dim]){
       _cellsPerDimension[dim]++;
    }
    numberOfCells *= _cellsPerDimension[dim];
    _cellLength[dim]=(this->_boundingBoxMax[dim]-this->_boundingBoxMin[dim])/((double)_cellsPerDimension[dim]-2.0*_haloWidthInNumCells[dim]);
    _haloBoundingBoxMin[dim] = this->_boundingBoxMin[dim]-_haloWidthInNumCells[dim]*_cellLength[dim];
    _haloBoundingBoxMax[dim] = this->_boundingBoxMax[dim]+_haloWidthInNumCells[dim]*_cellLength[dim];
    _haloLength[dim] = _haloWidthInNumCells[dim]*_cellLength[dim];
  }
  cout << "haloWidthInNumCells: " << _haloWidthInNumCells[0] << " / " << _haloWidthInNumCells[1] << " / " << _haloWidthInNumCells[2] << endl;

  _cells.resize(numberOfCells);
 
  // If the with of the inner region is less than the width of the halo region
  // a parallelisation isn't possible (with the used algorithms).
  // In this case, print an error message
  // _cellsPerDimension is 2 times the halo width + the inner width
  // so it has to be at least 3 times the halo width
  if(_cellsPerDimension[0] < 3*_haloWidthInNumCells[0] ||
     _cellsPerDimension[1] < 3*_haloWidthInNumCells[1] ||
     _cellsPerDimension[2] < 3*_haloWidthInNumCells[2]){
    _log.error("Constructor","bounding box too small for calculated cell Length");
    cout << "cellsPerDimension" << _cellsPerDimension[0] << " / " << _cellsPerDimension[1] << " / " << _cellsPerDimension[2] << endl;
    cout << "_haloWidthInNumCells" << _haloWidthInNumCells[0] << " / " << _haloWidthInNumCells[1] << " / " << _haloWidthInNumCells[2] << endl;
  }

#ifdef GRANDCANONICAL
   this->_localInsertionsMinusDeletions = 0;
#endif

#ifndef NDEBUG
  cout << "+++\nLINKED CELL PARALLELIZATION\n+++\n"
       << "_cellsPerDimension: (" << _cellsPerDimension[0] << " " << _cellsPerDimension[1]
       << " " << _cellsPerDimension[2] << ")\n_haloWidthInNumCells: ("
       << _haloWidthInNumCells[0] << " " << _haloWidthInNumCells[1]
       << " " << _haloWidthInNumCells[2] << ")\n_cellLength: (" << _cellLength[0]
       << " " << _cellLength[1] << " " << _cellLength[2]
       << ")\n_cellsInCutoffRadius: " << _cellsInCutoffRadius << "\n+++\n\n";
#endif

  initializeCells();
  calculateNeighbourIndices();
}

template<class ParticleType>
datastructures::LinkedCells<ParticleType>::~LinkedCells(){
}

template<class ParticleType>
void datastructures::LinkedCells<ParticleType>::update(){
  // clear all Cells
  typename std::vector<Cell<ParticleType> >::iterator celliter;
  for(celliter=(_cells).begin();celliter!=(_cells).end();++celliter){
    (*celliter).removeAllParticles();
  }
  
  unsigned long index; // index of the cell into which the pointer has to be inserted
  typename std::list<ParticleType>::iterator pos;
  for(pos=_particles.begin();pos!=_particles.end();++pos) {
    index=getCellIndexOfMolecule(&(*pos));
    if(index >= this->_cells.size())
    {
      cout << "\nSEVERE ERROR\n";
      cout << "ID " << pos->id() << "\nr:" << pos->r(0) << " / "  << pos->r(1) << " / "  << pos->r(2) << endl;
      cout << "v:" << pos->v(0) << " / "  << pos->v(1) << " / "  << pos->v(2) << endl;
      cout << "F:" << pos->F(0) << " / "  << pos->F(1) << " / "  << pos->F(2) << endl;
      cout << "Cell: " << index << endl;
      cout << "_cells.size(): " << _cells.size() << "\tindex: " << index << "\n";
      cout << "Length of the cell: " << _cellLength[0] << " " << _cellLength[1] << " " << _cellLength[2] << "\n";
      cout << "\nBounding box, including halo, from (" << _haloBoundingBoxMin[0] << "/"
           << _haloBoundingBoxMin[1] << "/" << _haloBoundingBoxMin[2] << ") to (" << _haloBoundingBoxMax[0]
           << "/" << _haloBoundingBoxMax[1] << "/" << _haloBoundingBoxMax[2] << ").\n";
      cout << "removing m" << pos->id() << " (internal component number " << pos->componentid()
           << ", Utrans=" << pos->Utrans() << ").\n";
      _log.error("update()", "SEVERE INDEX ERROR in LinkedCells.cpph method update:\nAolecule left the bounding box and will be deleted.\n");
      cout << "\n\n";
      this->_particles.erase(pos);
      exit(1);
    }
    else
    { 
#ifndef NDEBUG
      if (!(pos->id() % 65536)) cout << pos->id() << "\t" << index << "\t"
                                     << pos->r(0) << "  " << pos->r(1) << "  " << pos->r(2) << "\n";
#endif
      (_cells[index]).addParticle(&(*pos));
    }
  }
}

template<class ParticleType>
void datastructures::LinkedCells<ParticleType>::addParticle(ParticleType& particle){
  double x = particle.r(0);
  double y = particle.r(1);
  double z = particle.r(2);
  if(x>=this->_haloBoundingBoxMin[0] && x < this->_haloBoundingBoxMax[0] && 
     y>=this->_haloBoundingBoxMin[1] && y < this->_haloBoundingBoxMax[1] && 
     z>=this->_haloBoundingBoxMin[2] && z < this->_haloBoundingBoxMax[2]){
       _particles.push_front(particle);
  }
}

template<class ParticleType>
void datastructures::LinkedCells<ParticleType>::countParticles(Domain* d)
{
  typename vector<Cell<ParticleType> >::iterator cellIter;
  typename std::list<ParticleType*>::iterator molIter1;
  for(unsigned i=0; i < _cells.size(); i++)
  {
    Cell<ParticleType>& currentCell = _cells[i];
    if(currentCell.isHaloCell()) continue;
    for(molIter1=currentCell.getParticlePointers().begin(); molIter1!=currentCell.getParticlePointers().end(); molIter1++)
    {
      ParticleType& molecule1 = **molIter1;
      d->observeRDF(molecule1.componentid());
    }
  }
}

template<class ParticleType>
unsigned datastructures::LinkedCells<ParticleType>::countParticles(
   int cid
) {
   unsigned N = 0;
   typename vector<Cell<ParticleType> >::iterator cellIter;
   typename std::list<ParticleType*>::iterator molIter1;
   for(unsigned i=0; i < _cells.size(); i++)
   {
      Cell<ParticleType>& currentCell = _cells[i];
      if(currentCell.isHaloCell()) continue;
      for( molIter1=currentCell.getParticlePointers().begin();
           molIter1!=currentCell.getParticlePointers().end();
           molIter1++ )
      {
         if((*molIter1)->componentid() == cid) N++;
      }
   }
   return N;
}

template<class ParticleType>
unsigned datastructures::LinkedCells<ParticleType>::countParticles(
   int cid, double* cbottom, double* ctop
) {
   //X return this->countParticles(cid);

#ifndef NDEBUG
   cout << "\nCounting all particles between (" << cbottom[0] << " / " << cbottom[1] << " / " << cbottom[2] << ") and (" << ctop[0] << " / " << ctop[1] << " / " << ctop[2] << ").";
#endif

   int minIndex[3];
   int maxIndex[3];
   for(int d=0; d < 3; d++)
   {
      if(cbottom[d] < this->_haloBoundingBoxMin[d]) minIndex[d] = 0;
      else minIndex[d] = (int)floor(
         (cbottom[d] - this->_haloBoundingBoxMin[d]) / _cellLength[d]
      );
      if(ctop[d] > this->_haloBoundingBoxMax[d])
	 maxIndex[d] = (int)floor(
	    (this->_haloBoundingBoxMax[d] - _haloBoundingBoxMin[d])
	       / this->_cellLength[d]
         );
      else maxIndex[d] = (int)floor(
         (ctop[d] - this->_haloBoundingBoxMin[d]) / _cellLength[d]
      );

      if(minIndex[d] < 0) minIndex[d] = 0;
      if(maxIndex[d] >= _cellsPerDimension[d]) maxIndex[d] = _cellsPerDimension[d] - 1;
   }

#ifndef NDEBUG
   cout << "\nThis corresponds to cell indices from (" << minIndex[0] << " / " << minIndex[1] << " / " << minIndex[2] << ") to (" << maxIndex[0] << " / " << maxIndex[1] << " / " << maxIndex[2] << ").\n";
#endif
   
   unsigned N = 0;
   int cix[3];
   typename vector<Cell<ParticleType> >::iterator cellIter;
   typename std::list<ParticleType*>::iterator molIter1;
   bool individualCheck;
   int cellid;

   for(cix[0] = minIndex[0]; maxIndex[0] >= cix[0]; (cix[0])++)
      for(cix[1] = minIndex[1]; maxIndex[1] >= cix[1]; (cix[1])++)
	 for(cix[2] = minIndex[2]; maxIndex[2] >= cix[2]; (cix[2])++)
	 {
	    individualCheck = (cix[0] == minIndex[0]) || (cix[0] == minIndex[0] + 1) ||
	                      (cix[0] == maxIndex[0]) || (cix[0] == maxIndex[0] - 1) ||
	                      (cix[1] == minIndex[1]) || (cix[1] == minIndex[1] + 1) ||
	                      (cix[1] == maxIndex[1]) || (cix[1] == maxIndex[1] - 1) ||
	                      (cix[2] == minIndex[2]) || (cix[2] == minIndex[2] + 1) ||
	                      (cix[2] == maxIndex[2]) || (cix[2] == maxIndex[2] - 1);
	    cellid = this->cellIndexOf3DIndex(cix[0], cix[1], cix[2]);
            if(( cellid < 0 ) || ( cellid >= (int)(this->_cells.size()) )) continue;
            Cell<ParticleType>& currentCell = _cells[cellid];
            if(currentCell.isHaloCell()) continue;
	    if(individualCheck)
	    {
               for(molIter1=currentCell.getParticlePointers().begin();
                   molIter1!=currentCell.getParticlePointers().end();
                   molIter1++)
	       {
                  if( ((*molIter1)->r(0) > cbottom[0]) &&
		      ((*molIter1)->r(1) > cbottom[1]) &&
		      ((*molIter1)->r(2) > cbottom[2]) &&
		      ((*molIter1)->r(0) < ctop[0]) &&
		      ((*molIter1)->r(1) < ctop[1]) &&
		      ((*molIter1)->r(2) < ctop[2]) &&
		      ((*molIter1)->componentid() == cid) )
		  {
		     N++;
		  }
	       }
	    }
	    else
	    {
               for(molIter1=currentCell.getParticlePointers().begin();
                   molIter1!=currentCell.getParticlePointers().end();
                   molIter1++)
	       {
                  if((*molIter1)->componentid() == cid) N++;
	       }
	    }
	 }
   
   return N;
}

template<class ParticleType>
void datastructures::LinkedCells<ParticleType>::traversePairs()
{
  this->_particlePairsHandler.init();
  
  // XXX comment
  double distanceVector[3];
  // loop over all cells
  typename vector<Cell<ParticleType> >::iterator cellIter;
  typename std::list<ParticleType*>::iterator molIter1;
  typename std::list<ParticleType*>::iterator molIter2;
  for(cellIter=_cells.begin(); cellIter!= _cells.end(); cellIter++){
    for(molIter1=cellIter->getParticlePointers().begin(); molIter1!=cellIter->getParticlePointers().end(); molIter1++){
      (*molIter1)->setFM(0,0,0,0,0,0);
    }
  } 

  vector<unsigned long>::iterator cellIndexIter;
  vector<unsigned long>::iterator neighbourOffsetsIter;
  
  // sqare of the cutoffradius
  double cutoffRadiusSquare = _cutoffRadius * _cutoffRadius; 
  double LJCutoffRadiusSquare = _LJCutoffRadius * _LJCutoffRadius;
#ifdef COMPLEX_POTENTIAL_SET
  double tersoffCutoffRadiusSquare = _tersoffCutoffRadius * this->_tersoffCutoffRadius;
#endif
  double dd;

  /*
#ifndef NDEBUG
  for(int i=0; i < _cells.size(); i++)
  {
    Cell<ParticleType>& currentCell = _cells[i];
    cout.precision(3);
    cout << "cell /" << i << "/ (" << currentCell.getParticlePointers().size() << " molecules).\n";
    if(currentCell.getParticlePointers().size() == 0) continue;
    for(molIter1=currentCell.getParticlePointers().begin(); molIter1!=currentCell.getParticlePointers().end(); molIter1++)
    {
      ParticleType& molecule1 = **molIter1;
      cout << "molecule " << molecule1.id() << "[" << ((unsigned long)&molecule1) % 1000 << "] at ("
           << molecule1.r(0) << " / " << molecule1.r(1) << " / " << molecule1.r(2) << ")\n";
    }
    cout << "backward neigbours of cell /" << i << "/:  ";
    for(neighbourOffsetsIter=_backwardNeighbourOffsets.begin(); neighbourOffsetsIter!=_backwardNeighbourOffsets.end(); neighbourOffsetsIter++)
    {
      cout << "/" << (int)(i+*neighbourOffsetsIter) << "/  ";
    }
    cout << "\nforward neigbours of cell /" << i << "/:  ";
    for(neighbourOffsetsIter=_forwardNeighbourOffsets.begin(); neighbourOffsetsIter!=_forwardNeighbourOffsets.end(); neighbourOffsetsIter++)
    {
      cout << "/" << (int)(i+*neighbourOffsetsIter) << "/  ";
    }
    cout << "\n\n";
  }
  exit(1);
#endif
  */

#ifdef COMPLEX_POTENTIAL_SET
#ifndef NDEBUG
  //X cout << "disconnecting Tersoff pairs.\n";
#endif
  for(unsigned i=0; i < _cells.size(); i++)
  {
    Cell<ParticleType>& currentCell = _cells[i];
    for( molIter1=currentCell.getParticlePointers().begin();
         molIter1!=currentCell.getParticlePointers().end();
         molIter1++ )
    {
      ParticleType& molecule1 = **molIter1;
      molecule1.clearTersoffNeighbourList();
    }
  }
#endif

#ifndef NDEBUG  
  /*
#ifdef COMPLEX_POTENTIAL_SET
  cout << "processing pairs and preprocessing Tersoff pairs: "; 
#else
  cout << "processing pairs: ";
#endif
  cout << "cutoffRadiusSquare = " << cutoffRadiusSquare << ", LJCutoffRadiusSquare = " << LJCutoffRadiusSquare << "\n";
  */
#endif

  // loop over all inner cells and calculate forces to forward neighbours
  for(cellIndexIter=_innerCellIndices.begin(); cellIndexIter!=_innerCellIndices.end(); cellIndexIter++){
    Cell<ParticleType>& currentCell = _cells[*cellIndexIter];

    // forces between molecules in the cell
    for(molIter1=currentCell.getParticlePointers().begin(); molIter1!=currentCell.getParticlePointers().end(); molIter1++)
    {
      ParticleType& molecule1 = **molIter1;
#ifdef COMPLEX_POTENTIAL_SET
      if(molecule1.numTersoff() == 0)
      {
#endif
        for(molIter2=molIter1; molIter2!=currentCell.getParticlePointers().end(); molIter2++)
        {
          ParticleType& molecule2 = **molIter2;
          if(&molecule1 != &molecule2)
          { 
            dd = molecule2.dist2(molecule1,distanceVector);
            if(dd < cutoffRadiusSquare)
            {
              this->_particlePairsHandler.processPair(molecule1,molecule2,distanceVector,0,dd,(dd < LJCutoffRadiusSquare));
            }
          }
        }
#ifdef COMPLEX_POTENTIAL_SET
      }
      else
      {
        for(molIter2=molIter1; molIter2!=currentCell.getParticlePointers().end(); molIter2++)
        {
          ParticleType& molecule2 = **molIter2;
          if(&molecule1 != &molecule2)
          { 
            dd = molecule2.dist2(molecule1,distanceVector);
            if(dd < cutoffRadiusSquare)
            {
              this->_particlePairsHandler.processPair(molecule1,molecule2,distanceVector,0,dd,(dd < LJCutoffRadiusSquare));
              if((molecule2.numTersoff() > 0) && (dd < tersoffCutoffRadiusSquare))
              {
                 this->_particlePairsHandler.preprocessTersoffPair(molecule1,molecule2,false);
              }
            }
          }
        }
      }
#endif
    }

    // loop over all neighbours
    for(neighbourOffsetsIter=_forwardNeighbourOffsets.begin(); neighbourOffsetsIter!=_forwardNeighbourOffsets.end(); neighbourOffsetsIter++){
      Cell<ParticleType>& neighbourCell = _cells[*cellIndexIter+*neighbourOffsetsIter];
      // loop over all particles in the cell
      for(molIter1=currentCell.getParticlePointers().begin(); molIter1!=currentCell.getParticlePointers().end(); molIter1++){
        ParticleType& molecule1 = **molIter1;

#ifdef COMPLEX_POTENTIAL_SET
        if(molecule1.numTersoff() == 0)
        {
#endif
          for(molIter2=neighbourCell.getParticlePointers().begin(); molIter2!=neighbourCell.getParticlePointers().end(); molIter2++)
          {
            ParticleType& molecule2 = **molIter2;
            dd = molecule2.dist2(molecule1,distanceVector);
            if(dd < cutoffRadiusSquare)
            {
              this->_particlePairsHandler.processPair(molecule1,molecule2,distanceVector,0,dd,(dd < LJCutoffRadiusSquare));
            }
          }
#ifdef COMPLEX_POTENTIAL_SET
        }
        else
        {
          for(molIter2=neighbourCell.getParticlePointers().begin(); molIter2!=neighbourCell.getParticlePointers().end(); molIter2++)
          {
            ParticleType& molecule2 = **molIter2;
            dd = molecule2.dist2(molecule1,distanceVector);
            if(dd < cutoffRadiusSquare)
            {
              this->_particlePairsHandler.processPair(molecule1,molecule2,distanceVector,0,dd,(dd < LJCutoffRadiusSquare));
              if((molecule2.numTersoff() > 0) && (dd < tersoffCutoffRadiusSquare))
                this->_particlePairsHandler.preprocessTersoffPair(molecule1,molecule2,false);
            }
          }
        }
#endif

      }
    }
  }

#ifdef COMPLEX_POTENTIAL_SET
  // loop over halo cells and detect Tersoff neighbours within the halo
  // this is relevant for the angle summation
  for(unsigned i=0; i < _cells.size(); i++)
  {
    Cell<ParticleType>& currentCell = _cells[i];
    if(!currentCell.isHaloCell()) continue;

    for( molIter1=currentCell.getParticlePointers().begin();
         molIter1!=currentCell.getParticlePointers().end();
         molIter1++ )
    {
      ParticleType& molecule1 = **molIter1;
      if(molecule1.numTersoff() == 0) continue;
#ifndef NDEBUG
      // cout << "\tatom " << molecule1.id() << " (halo cell " << i << ") <-> halo cell " << i << ".\n";
#endif
      for(molIter2=molIter1; molIter2!=currentCell.getParticlePointers().end(); molIter2++)
      {
        ParticleType& molecule2 = **molIter2;
        if((&molecule1 != &molecule2) && (molecule2.numTersoff() > 0))
        { 
          dd = molecule2.dist2(molecule1, distanceVector);
          if(dd < tersoffCutoffRadiusSquare)
            this->_particlePairsHandler.preprocessTersoffPair(molecule1, molecule2, true);
        }
      }

      for( neighbourOffsetsIter=_forwardNeighbourOffsets.begin();
           neighbourOffsetsIter!=_forwardNeighbourOffsets.end();
           neighbourOffsetsIter++ )
      {
        int j = i + *neighbourOffsetsIter;
        if((j < 0) || (j >= (int)(this->_cells.size()))) continue;
        Cell<ParticleType>& neighbourCell = _cells[j];
        if(!neighbourCell.isHaloCell()) continue;
#ifndef NDEBUG
        // cout << "\tatom " << molecule1.id() << " (halo cell " << i << ") <-> halo cell " << j << ".\n";
#endif
        for( molIter2=neighbourCell.getParticlePointers().begin();
             molIter2!=neighbourCell.getParticlePointers().end();
             molIter2++ )
        {
          ParticleType& molecule2 = **molIter2;
          if(molecule2.numTersoff() == 0) continue;
          dd = molecule2.dist2(molecule1, distanceVector);
          if(dd < tersoffCutoffRadiusSquare)
            this->_particlePairsHandler.preprocessTersoffPair(molecule1, molecule2, true);
        }
      }
    }
  }
#endif

  // loop over all boundary cells and calculate forces to forward and backward neighbours
  for(cellIndexIter=_boundaryCellIndices.begin(); cellIndexIter!=_boundaryCellIndices.end(); cellIndexIter++){
    Cell<ParticleType>& currentCell = _cells[*cellIndexIter];

    // forces between molecules in the cell
    for(molIter1=currentCell.getParticlePointers().begin(); molIter1!=currentCell.getParticlePointers().end(); molIter1++){
      ParticleType& molecule1 = **molIter1;

#ifdef COMPLEX_POTENTIAL_SET
      if(molecule1.numTersoff() == 0)
      {
#endif
        for(molIter2=molIter1; molIter2!=currentCell.getParticlePointers().end(); molIter2++)
        {
          ParticleType& molecule2 = **molIter2;
          if(&molecule1 != &molecule2)
          { 
            dd = molecule2.dist2(molecule1,distanceVector);
            if(dd < cutoffRadiusSquare)
            {
               this->_particlePairsHandler.processPair(molecule1,molecule2,distanceVector,0,dd,(dd < LJCutoffRadiusSquare));
            }
          }
        }
#ifdef COMPLEX_POTENTIAL_SET
      }
      else
      {
        for(molIter2=molIter1; molIter2!=currentCell.getParticlePointers().end(); molIter2++)
        {
          ParticleType& molecule2 = **molIter2;
          if(&molecule1 != &molecule2)
          { 
            dd = molecule2.dist2(molecule1,distanceVector);
            if(dd < cutoffRadiusSquare)
            {
              this->_particlePairsHandler.processPair(molecule1,molecule2,distanceVector,0,dd,(dd < LJCutoffRadiusSquare));
              if((molecule2.numTersoff() > 0) && (dd < tersoffCutoffRadiusSquare))
                this->_particlePairsHandler.preprocessTersoffPair(molecule1,molecule2,false);
            }
          }
        }
      }
#endif

    }

    // loop over all forward neighbours
    for(neighbourOffsetsIter=_forwardNeighbourOffsets.begin(); neighbourOffsetsIter!=_forwardNeighbourOffsets.end(); neighbourOffsetsIter++){
      Cell<ParticleType>& neighbourCell = _cells[*cellIndexIter+*neighbourOffsetsIter];
      // loop over all particles in the cell
      for(molIter1=currentCell.getParticlePointers().begin(); molIter1!=currentCell.getParticlePointers().end(); molIter1++){
        ParticleType& molecule1 = **molIter1;

#ifdef COMPLEX_POTENTIAL_SET
	if(molecule1.numTersoff() == 0)
        {
#endif
          for(molIter2=neighbourCell.getParticlePointers().begin(); molIter2!=neighbourCell.getParticlePointers().end(); molIter2++)
          {
            ParticleType& molecule2 = **molIter2;
            dd = molecule2.dist2(molecule1,distanceVector);
            if(dd < cutoffRadiusSquare)
            {
              this->_particlePairsHandler.processPair(molecule1,molecule2,distanceVector,0,dd,(dd < LJCutoffRadiusSquare));
            }
          }
#ifdef COMPLEX_POTENTIAL_SET
        }
        else
        {
          for(molIter2=neighbourCell.getParticlePointers().begin(); molIter2!=neighbourCell.getParticlePointers().end(); molIter2++)
          {
            ParticleType& molecule2 = **molIter2;
            dd = molecule2.dist2(molecule1,distanceVector);
            if(dd < cutoffRadiusSquare)
            {
              this->_particlePairsHandler.processPair(molecule1,molecule2,distanceVector,0,dd,(dd < LJCutoffRadiusSquare));
              if((molecule2.numTersoff() > 0) && (dd < tersoffCutoffRadiusSquare))
                this->_particlePairsHandler.preprocessTersoffPair(molecule1,molecule2,false);
            }
          }
        }
#endif

      }
    }

    // loop over all backward neighbours. calculate only forces
    // to neighbour cells in the halo region, all others already have been calculated
    // Upot6LJ,... must not be changed, as this force-pair is also calculated in one of the other loops
    for(neighbourOffsetsIter=_backwardNeighbourOffsets.begin(); neighbourOffsetsIter!=_backwardNeighbourOffsets.end(); neighbourOffsetsIter++){
      Cell<ParticleType>& neighbourCell = _cells[*cellIndexIter+*neighbourOffsetsIter];
      if(neighbourCell.isHaloCell()){
        // loop over all particles in the cell
        for(molIter1=currentCell.getParticlePointers().begin(); molIter1!=currentCell.getParticlePointers().end(); molIter1++){
          ParticleType& molecule1 = **molIter1;

#ifdef COMPLEX_POTENTIAL_SET
          if(molecule1.numTersoff() == 0)
          {
#endif
            for(molIter2=neighbourCell.getParticlePointers().begin(); molIter2!=neighbourCell.getParticlePointers().end(); molIter2++)
            {
              ParticleType& molecule2 = **molIter2;
              dd = molecule2.dist2(molecule1,distanceVector);
              if(dd < cutoffRadiusSquare)
              {
                this->_particlePairsHandler.processPair(molecule1,molecule2,distanceVector,1,dd,(dd < LJCutoffRadiusSquare));
              }
            }
#ifdef COMPLEX_POTENTIAL_SET
          }
          else
          {
            for(molIter2=neighbourCell.getParticlePointers().begin(); molIter2!=neighbourCell.getParticlePointers().end(); molIter2++)
            {
              ParticleType& molecule2 = **molIter2;
              dd = molecule2.dist2(molecule1,distanceVector);
              if(dd < cutoffRadiusSquare)
              {
                this->_particlePairsHandler.processPair(molecule1,molecule2,distanceVector,1,dd,(dd < LJCutoffRadiusSquare));
                if((molecule2.numTersoff() > 0) && (dd < tersoffCutoffRadiusSquare))
                  this->_particlePairsHandler.preprocessTersoffPair(molecule1,molecule2,true);
              }
            }
          }
#endif

        }
      }
    }
  }
  
#ifdef COMPLEX_POTENTIAL_SET
#ifndef NDEBUG
  //X cout << "processing Tersoff potential.\n";  
#endif
  double params[15];
  double delta_r;
  bool knowparams = false;

  for(cellIndexIter=_innerCellIndices.begin(); cellIndexIter!=_boundaryCellIndices.end(); cellIndexIter++)
  {
    if(cellIndexIter == this->_innerCellIndices.end())
      cellIndexIter = this->_boundaryCellIndices.begin();
    Cell<ParticleType>& currentCell = _cells[*cellIndexIter];
    for( molIter1=currentCell.getParticlePointers().begin();
         molIter1!=currentCell.getParticlePointers().end();
         molIter1++ )
    {
      ParticleType& molecule1 = **molIter1;
      if(molecule1.numTersoff() == 0) continue;
      if(!knowparams)
      {
         delta_r = molecule1.tersoffParameters(params);
         knowparams = true;
      }
      this->_particlePairsHandler.processTersoffAtom(molecule1, params, delta_r);
    }
  }

  /*
  for(cellIndexIter=_innerCellIndices.begin(); cellIndexIter!=_boundaryCellIndices.end(); cellIndexIter++)
  {
    if(cellIndexIter == this->_innerCellIndices.end())
      cellIndexIter = this->_boundaryCellIndices.begin();
    Cell<ParticleType>& currentCell = _cells[*cellIndexIter];
    for( molIter1=currentCell.getParticlePointers().begin();
         molIter1!=currentCell.getParticlePointers().end();
         molIter1++ )
    {
      ParticleType& molecule1 = **molIter1;
      if(molecule1.numTersoff() == 0) continue;
      int pairCode = 0;
      unsigned curTN = molecule1.getCurTN();
#ifndef NDEBUG
      if(curTN != 3)
      {
         cerr << "graphite structure error!\nID " << molecule1.id() << " (" << molecule1.r(0) << " / " << molecule1.r(1) << " / " << molecule1.r(2) << ") has " << curTN << " neighbours.\n";
         cerr.flush();
      }
#endif
      for(unsigned i = 0; i < curTN; i++)
      {
        ParticleType& molecule2 = *(molecule1.getTersoffNeighbour(i));
        molecule2.dist2(molecule1,distanceVector);
        pairCode = molecule1.getPairCode(i)? 1: 0;
        this->_particlePairsHandler.processTersoffPair(molecule1, molecule2, distanceVector, pairCode);
      }
    }
  }
  */
#endif

  this->_particlePairsHandler.finish();
}

template<class ParticleType>
unsigned long datastructures::LinkedCells<ParticleType>::getNumberOfParticles(){
  return _particles.size(); 
}      

template<class ParticleType>
void datastructures::LinkedCells<ParticleType>::initializeCells(){
  _innerCellIndices.clear();
  unsigned long cellIndex;
  for(int iz=0; iz<_cellsPerDimension[2]; ++iz) {
    for(int iy=0; iy<_cellsPerDimension[1]; ++iy) {
      for(int ix=0; ix<_cellsPerDimension[0]; ++ix) {
        cellIndex = cellIndexOf3DIndex(ix,iy,iz);
        /*
#ifndef NDEBUG
        cout << "create cell /" << cellIndex << "/ at <ix=" << ix << ", iy=" << iy << ", iz=" << iz << "> ";
#endif
        */
        if(ix < _haloWidthInNumCells[0] || iy < _haloWidthInNumCells[1] || iz < _haloWidthInNumCells[2] ||
           ix >= _cellsPerDimension[0]-_haloWidthInNumCells[0] ||
           iy >= _cellsPerDimension[1]-_haloWidthInNumCells[1] ||
           iz >= _cellsPerDimension[2]-_haloWidthInNumCells[2])
        {
          _cells[cellIndex].assignCellToHaloRegion();
          /*
#ifndef NDEBUG
          cout << " in the halo.\n";
#endif
          */
        }
        else if (ix < 2*_haloWidthInNumCells[0] || iy < 2*_haloWidthInNumCells[1] || iz < 2*_haloWidthInNumCells[2] ||
           ix >= _cellsPerDimension[0]-2*_haloWidthInNumCells[0] ||
           iy >= _cellsPerDimension[1]-2*_haloWidthInNumCells[1] ||
           iz >= _cellsPerDimension[2]-2*_haloWidthInNumCells[2])
        {
          _cells[cellIndex].assignCellToBoundaryRegion();
          _boundaryCellIndices.push_back(cellIndex);
          /*
#ifndef NDEBUG
          cout << " as part of the boundary.\n";
#endif
          */
        }
        else
        {
          _cells[cellIndex].assignCellToInnerRegion();
          _innerCellIndices.push_back(cellIndex);
          /*
#ifndef NDEBUG
          cout << " as an inner cell.\n";
#endif
          */
        }
      }
    }
  }
}

template<class ParticleType>
void datastructures::LinkedCells<ParticleType>::calculateNeighbourIndices(){ 
  double xDistanceSquare;
  double yDistanceSquare;
  double zDistanceSquare;
  double cutoffRadiusSquare = pow(_cutoffRadius,2);
  for(int zIndex=-_haloWidthInNumCells[2]; zIndex<=_haloWidthInNumCells[2]; zIndex++) {
    // The distance in one dimension is the width of a cell multiplied with the number 
    // of cells between the two cells (this is received by substracting one of the 
    // absolute difference of the cells, if this difference is not zero)
    if(zIndex != 0){
      zDistanceSquare = pow((abs(zIndex)-1) * _cellLength[2],2);
    }
    else {
      zDistanceSquare = 0;
    }
    for(int yIndex=-_haloWidthInNumCells[1]; yIndex<=_haloWidthInNumCells[1]; yIndex++) {
      if(yIndex != 0){
        yDistanceSquare = pow((abs(yIndex)-1) * _cellLength[1],2);
      }
      else {
        yDistanceSquare = 0;
      }
      for(int xIndex=-_haloWidthInNumCells[0]; xIndex<=_haloWidthInNumCells[0]; xIndex++) {
        if(xIndex != 0){
          xDistanceSquare = pow((abs(xIndex)-1) * _cellLength[0],2);
        }
        else {
          xDistanceSquare = 0;
        }
        if(xDistanceSquare+yDistanceSquare+zDistanceSquare <= cutoffRadiusSquare) {
          long offset = cellIndexOf3DIndex(xIndex, yIndex, zIndex);
          if(offset > 0){
            _forwardNeighbourOffsets.push_back(offset);
          }
          if(offset < 0){
            _backwardNeighbourOffsets.push_back(offset);
          }
        }
      }
    }
  }
}

template<class ParticleType>
unsigned long datastructures::LinkedCells<ParticleType>::getCellIndexOfMolecule(ParticleType* molecule) {
  int cellIndex[3]; // 3D Cell index

  for(int dim=0; dim<3; dim++){
#ifndef NDEBUG
    if(molecule->r(dim) < _haloBoundingBoxMin[dim] || molecule->r(dim) >= _haloBoundingBoxMax[dim]){
      _log.error("getCellIndexOfMolecule(ParticleType* molecule)", "Molecule is outside of the bounding box");
    } 
#endif
    cellIndex[dim] = (int) floor((molecule->r(dim)-_haloBoundingBoxMin[dim])/_cellLength[dim]);
  }
  // cerr << molecule->r(0) << " " << molecule->r(1) << " " << molecule->r(2) << "\n";
  // cerr << _haloBoundingBoxMin[0] << " " << _haloBoundingBoxMin[1] << " " << _haloBoundingBoxMin[2] << "\n";
  // cerr << _cellLength[0] << " " << _cellLength[1] << " " << _cellLength[2] << "\n";
  // cerr << cellIndex[0] << " " << cellIndex[1] << " " << cellIndex[2] << "\n";
  // cerr << "return " << (cellIndex[2]*_cellsPerDimension[1]+cellIndex[1]) * _cellsPerDimension[0] + cellIndex[0] << ";\n";
  // exit(1);
  return (cellIndex[2]*_cellsPerDimension[1]+cellIndex[1]) * _cellsPerDimension[0] + cellIndex[0]; 
}

template<class ParticleType>
unsigned long datastructures::LinkedCells<ParticleType>::cellIndexOf3DIndex(int xIndex, int yIndex, int zIndex){
  return (zIndex * _cellsPerDimension[1] + yIndex) * _cellsPerDimension[0] + xIndex;

}

template<class ParticleType>
double datastructures::LinkedCells<ParticleType>::get_halo_L(int index){
  return _haloLength[index]; 
}

template<class ParticleType>
ParticleType* datastructures::LinkedCells<ParticleType>::begin(){
  _particleIter = _particles.begin();
  if(_particleIter != _particles.end()){
    return &(*_particleIter);
  }
  else {
    return NULL;
  }
}

template<class ParticleType>
ParticleType* datastructures::LinkedCells<ParticleType>::next(){
  _particleIter++;
  if(_particleIter != _particles.end()){
    return &(*_particleIter);
  }
  else {
    return NULL;
  }
}

template<class ParticleType>
ParticleType* datastructures::LinkedCells<ParticleType>::end(){
  return NULL;
}


template<class ParticleType>
void datastructures::LinkedCells<ParticleType>::deleteOuterParticles(){ 
#ifndef NDEBUG
  //X cout << "clearing halo: ";  
#endif
  typename std::list<ParticleType>::iterator particleIterator = _particles.begin();
  
  bool erase_mol;
  while(particleIterator!=_particles.end()){
    erase_mol = false;
    for(unsigned short d=0;d<3;++d){
      const double& rd=particleIterator->r(d);
      // The molecules has to be within the domain of the process
      // If it is outside in at least one dimension, it has to be
      // erased /
      if(rd<this->_boundingBoxMin[d] || rd>=this->_boundingBoxMax[d]) erase_mol = true;
    }
    if(erase_mol) {
#ifndef NDEBUG
      //X cout << "erasing particle " << particleIterator->id() << ".\n";
#endif
      particleIterator=_particles.erase(particleIterator);
    }
    else{
      particleIterator++;
    }
  }
#ifndef NDEBUG
  //X cout << "halo cleared.\n";  
#endif
}

#ifdef GRANDCANONICAL
template<class ParticleType>
void datastructures::LinkedCells<ParticleType>::deleteMolecule
(
   unsigned long molid, double x, double y, double z
)
{
   int ix = (int)floor((x - this->_haloBoundingBoxMin[0]) / this->_cellLength[0]);
   int iy = (int)floor((y - this->_haloBoundingBoxMin[1]) / this->_cellLength[1]);
   int iz = (int)floor((z - this->_haloBoundingBoxMin[2]) / this->_cellLength[2]);
   unsigned long hash = this->cellIndexOf3DIndex(ix, iy, iz);
   if(hash >= this->_cells.size())
   {
      cout << "SEVERE ERROR: coordinates for atom deletion lie outside bounding box.\n";
      exit(1);
   }
   bool found = this->_cells[hash].deleteMolecule(molid);
   if(!found)
   {
      cout << "SEVERE ERROR: could not delete molecule " << molid << ".\n";
      exit(1);
   }
}

template<class ParticleType>
double datastructures::LinkedCells<ParticleType>::getEnergy(ParticleType* m1)
{
   double u = 0.0;

   typename std::list<ParticleType*>::iterator molIter2;
   vector<unsigned long>::iterator neighbourOffsetsIter;
  
   // sqare of the cutoffradius
   double cutoffRadiusSquare = _cutoffRadius * _cutoffRadius; 
   double LJCutoffRadiusSquare = _LJCutoffRadius * _LJCutoffRadius;
   double dd;
   double distanceVector[3];

   unsigned long cellIndex = getCellIndexOfMolecule(m1);
   Cell<ParticleType>& currentCell = _cells[cellIndex];

#ifdef COMPLEX_POTENTIAL_SET
   if(m1->numTersoff() > 0)
   {
      // molecules in the cell
      for( molIter2 = currentCell.getParticlePointers().begin();
           molIter2 != currentCell.getParticlePointers().end();
           molIter2++ )
      {
         if(m1->id() == (*molIter2)->id()) continue;
         if((*molIter2)->numTersoff() > 0) continue;
         dd = (*molIter2)->dist2(*m1, distanceVector);
         if(dd > cutoffRadiusSquare) continue;
         u += this->_particlePairsHandler.processPair(*m1, **molIter2, distanceVector, 2, dd, (dd < LJCutoffRadiusSquare));
      }

      // backward and forward neighbours
      for( neighbourOffsetsIter = _backwardNeighbourOffsets.begin();
           neighbourOffsetsIter != _forwardNeighbourOffsets.end();
           neighbourOffsetsIter++ )
      {
         if(neighbourOffsetsIter == _backwardNeighbourOffsets.end())
            neighbourOffsetsIter = _forwardNeighbourOffsets.begin();

         Cell<ParticleType>& neighbourCell = _cells[cellIndex + *neighbourOffsetsIter];
         for( molIter2 = neighbourCell.getParticlePointers().begin();
              molIter2 != neighbourCell.getParticlePointers().end();
              molIter2++ )
         {
            if((*molIter2)->numTersoff() > 0) continue;
            dd = (*molIter2)->dist2(*m1, distanceVector);
            if(dd > cutoffRadiusSquare) continue;
            u += this->_particlePairsHandler.processPair(*m1, **molIter2, distanceVector, 2, dd, (dd < LJCutoffRadiusSquare));
         }
      }
   }
   else
   {
#endif

      // molecules in the cell
      for( molIter2 = currentCell.getParticlePointers().begin();
           molIter2 != currentCell.getParticlePointers().end();
           molIter2++ )
      {
         if(m1->id() == (*molIter2)->id()) continue;
         dd = (*molIter2)->dist2(*m1, distanceVector);
         if(dd > cutoffRadiusSquare) continue;
         u += this->_particlePairsHandler.processPair(*m1, **molIter2, distanceVector, 2, dd, (dd < LJCutoffRadiusSquare));
      }

      // backward and forward neighbours
      for( neighbourOffsetsIter = _backwardNeighbourOffsets.begin();
           neighbourOffsetsIter != _forwardNeighbourOffsets.end();
           neighbourOffsetsIter++ )
      {
         if(neighbourOffsetsIter == _backwardNeighbourOffsets.end())
            neighbourOffsetsIter = _forwardNeighbourOffsets.begin();

         Cell<ParticleType>& neighbourCell = _cells[cellIndex + *neighbourOffsetsIter];
         for( molIter2 = neighbourCell.getParticlePointers().begin();
              molIter2 != neighbourCell.getParticlePointers().end();
              molIter2++ )
         {
            dd = (*molIter2)->dist2(*m1, distanceVector);
            if(dd > cutoffRadiusSquare) continue;
            u += this->_particlePairsHandler.processPair(*m1, **molIter2, distanceVector, 2, dd, (dd < LJCutoffRadiusSquare));
         }
      }

#ifdef COMPLEX_POTENTIAL_SET
   }
#endif
   return u;
}

template<class ParticleType>
int datastructures::LinkedCells<ParticleType>::grandcanonicalBalance(parallel::DomainDecompBase* comm)
{
   int universalInsertionsMinusDeletions = this->_localInsertionsMinusDeletions;
   comm->reducevalues(&universalInsertionsMinusDeletions);
   return universalInsertionsMinusDeletions;
}

template<class ParticleType>
void datastructures::LinkedCells<ParticleType>::grandcanonicalStep
(
   ensemble::ChemicalPotential* mu,
   double T
)
{
   bool accept = true;
   double DeltaUpot;
   ParticleType* m;

   this->_localInsertionsMinusDeletions = 0;

   mu->submitTemperature(T);
   double minco[3];
   double maxco[3];
   for(int d=0; d < 3; d++)
   {
      minco[d] = this->getBoundingBoxMin(d);
      maxco[d] = this->getBoundingBoxMax(d);
   }

   bool hasDeletion = true;
   bool hasInsertion = true;
   double ins[3];
   unsigned nextid = 0;
   while(hasDeletion || hasInsertion)
   {
      if(hasDeletion)
         hasDeletion = mu->getDeletion(this, minco, maxco);
      if(hasDeletion)
      {
         m = &(*(this->_particleIter));
         DeltaUpot = -1.0 * getEnergy(m);

#ifndef NDEBUG
         // cout << "rank " << mu->rank() << ": can I delete " << m->id() << "? ";
#endif
         accept = mu->decideDeletion(DeltaUpot / T);
#ifndef NDEBUG
         if(accept) cout << "r" << mu->rank() << "d" << m->id() << "\n";
         else cout << "   (r" << mu->rank() << "-d" << m->id() << ")\n";
         cout.flush();
#endif
         if(accept)
         {
            m->upd_cache();
            // m->clearFM();
            m->setFM(0.0,0.0,0.0,0.0,0.0,0.0);
            mu->storeMolecule(*m);
            this->deleteMolecule(m->id(), m->r(0), m->r(1), m->r(2));
            this->_particles.erase(this->_particleIter);
            this->_particleIter = _particles.begin();
            this->_localInsertionsMinusDeletions--;
         }
      }

      if(hasInsertion)
      {
         nextid = mu->getInsertion(ins);
         hasInsertion = (nextid > 0);
      }
      if(hasInsertion)
      {
         // for(int d = 0; d < 3; d++)
         //    ins[d] = ins[d]-coords[d]*proc_domain_L[d]-m_rmin[d];
         ParticleType tmp = mu->loadMolecule();
         for(int d=0; d < 3; d++) tmp.setr(d, ins[d]);
         tmp.setid(nextid);
         this->_particles.push_back(tmp);

         typename std::list<ParticleType>::iterator mit = _particles.end();
         mit--;
         m = &(*mit);
         m->upd_cache();
         // m->clearFM();
         m->setFM(0.0,0.0,0.0,0.0,0.0,0.0);
         m->check(nextid); 
#ifndef NDEBUG
         cout << "rank " << mu->rank() << ": insert " << m->id() 
              << " at the reduced position (" << ins[0] << "/" << ins[1] << "/" << ins[2] << ")? ";
         cout.flush();
#endif

         unsigned long cellid = this->getCellIndexOfMolecule(m);
         this->_cells[cellid].addParticle(m);
         DeltaUpot = getEnergy(m);
         accept = mu->decideInsertion(DeltaUpot/T);

#ifndef NDEBUG
         if(accept) cout << "r" << mu->rank() << "i" << mit->id() << ")\n";
         else cout << "   (r" << mu->rank() << "-i" << mit->id() << ")\n";
         cout.flush();
#endif
         if(accept)
         {
            this->_localInsertionsMinusDeletions++;
         }
         else
         {
            // this->deleteMolecule(m->id(), m->r(0), m->r(1), m->r(2));
            this->_cells[cellid].deleteMolecule(m->id());

            mit->check(m->id());
            this->_particles.erase(mit);
         }
      }
   }
   for(m = this->begin(); m != this->end(); m = this->next())
   {
#ifndef NDEBUG
      m->check(m->id());
#endif
      /*
      m->setFM(0.0,0.0,0.0,0.0,0.0,0.0);
#ifndef NDEBUG
      m->check(m->id());
#endif
      */
   }
}
#endif
