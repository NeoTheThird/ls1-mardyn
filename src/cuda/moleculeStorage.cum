#include <host_defines.h>

#include "util.cum"

#include "molecule.cum"
#include "cellInfo.cum"

// global shared data pointers
CONSTANT __device__ floatType3 *moleculePositions;
CONSTANT __device__ Matrix3x3 *moleculeRotations;

CONSTANT __device__ floatType3 *moleculeForces;
CONSTANT __device__ floatType3 *moleculeTorque;

CONSTANT __device__ Molecule::ComponentType *moleculeComponentTypes;

CONSTANT __device__ int *cellStartIndices;

__device__ CellInfo cellInfoFromCellIndex( int index ) {
	return CellInfo( cellStartIndices[index], cellStartIndices[index+1] );
}

struct MoleculeStorage {
	// straight-forward getter/setter
	__device__ void get(int index, Molecule &molecule) {
		molecule = Molecule( moleculePositions[index], moleculeRotations[index], moleculeForces[index], moleculeTorque[index], moleculeComponentTypes[index] );
	}

	__device__ 	void set(int index, const Molecule &molecule) {
		moleculeForces[ index ] = molecule.force;
		moleculeTorque[ index ] = molecule.torque;
	}

	// get the molecule data but in a way that merge will be able to merge changes back into the storage
	// (ie. force is set 0 in getMergable, so that merge can add molecule.force to the stored value instead of assigning it
	__device__ void getMergable(int index, Molecule &molecule) {
		molecule = Molecule( moleculePositions[index], moleculeRotations[index], make_floatType3( 0.0 ), make_floatType3( 0.0 ), moleculeComponentTypes[index] );
	}

	__device__ void merge(int index, const Molecule &molecule) {
		moleculeForces[ index ] += molecule.force;
		moleculeTorque[ index ] += molecule.torque;
	}

	template<int blockSize>
	struct MoleculeLocalStorage {
		floatType3 positions[blockSize];
		Matrix3x3 rotations[blockSize];

		floatType3 forces[blockSize];
		floatType3 torque[blockSize];

		Molecule::ComponentType componentTypes[blockSize];

		// straight-forward getter/setter
		__device__ void get(int index, Molecule &molecule) {
			molecule = Molecule( positions[index], rotations[index], forces[index], torque[index], componentTypes[index] );
		}

		__device__ void set(int index, const Molecule &molecule) {
			forces[ index ] = molecule.force;
			torque[ index ] = molecule.torque;
		}

		// get the molecule data but in a way that merge will be able to merge changes back into the storage
		// (ie. force is set 0 in getMergable, so that merge can add molecule.force to the stored value instead of assigning it
		__device__ void getMergable(int index, Molecule &molecule) {
			molecule = Molecule( positions[index], rotations[index], make_floatType3( 0.0 ), make_floatType3( 0.0 ), componentTypes[index]  );
		}

		__device__ void merge(int index, const Molecule &molecule) {
			forces[ index ] += molecule.force;
			torque[ index ] += molecule.torque;
		}

		__device__ void load(int localIndex, MoleculeStorage &storage, int index) {
			positions[localIndex] = moleculePositions[index];
			rotations[localIndex] = moleculeRotations[index];
			forces[localIndex] = moleculeForces[index];
			torque[localIndex] = moleculeTorque[index];
			componentTypes[localIndex] = moleculeComponentTypes[index];
		}

		__device__ void commit(int localIndex, MoleculeStorage &storage, int index) {
			moleculeForces[index] = forces[localIndex];
			moleculeTorque[index] = torque[localIndex];
		}
	};
};
