#ifndef LOCKS_CUM__
#define LOCKS_CUM__

#include "sharedDecls.h"

namespace Lock {
	class WaitForFirstWarp {
		volatile uint lockValue;

	public:
		__device__ WaitForFirstWarp() : lockValue( 0u ) {}

		// first to enter doesn't have to wait, all others do
		// returns whether the thread was the first (true), or not
		__device__ bool lock() {
			uint index = atomicInc( (uint*) &lockValue, 0u );

			if( index > 0u ) {
				// spin until the first lock is done
				while( lockValue > 0u )
					;

				return false;
			}
			return true;
		}

		__device__ void notifyAll() {
			lockValue = 0u;
		}
	};

	class OrderedWarp {
		volatile uint lockValue;

	public:
		__device__ OrderedWarp() : lockValue( 0 ) {}

		// first to enter doesn't have to wait, all others do
		// returns whether the thread was the first (true), or not
		__device__ bool lock() {
			uint index = atomicInc( (uint*) &lockValue, 0 );

			if( index > 0) {
				// spin until the first lock is done
				while( lockValue > index )
					;

				return false;
			}
			return true;
		}

		// TODO: notify -> unlock
		__device__ void notifyAll() {
			lockValue = 0;
		}

		__device__ void notify() {
			atomicDec( (uint*) &lockValue, ~0u );
		}
	};

#if 0
	class UnorderedWarp {
		volatile uint lockValue;

	public:
		__device__ UnorderedWarp() : lockValue( 0 ) {}

		__device__ void lock() {
			const uint index = atomInc( (uint*) &lockValue, 0 );

			if( index > 0 ) {
				while( true ) {
					if( lockValue == 0 ) {
						const uint myInnerLock = atomInc( (uint*) &lockValue, 0 );

						if( index == 0 )
							break;
					}
				}
			}
		}

		__device__ void unlock() {
			lockValue = 0;
		}
	};
#else
	class UnorderedWarp {
		volatile uint lockValue;

	public:
		__device__ UnorderedWarp() : lockValue( 0u ) {}

		__device__ void lock() {
			while( atomicExch( (uint*) &lockValue, 1u ) != 0u )
				;
		}

		__device__ void unlock() {
			lockValue = 0u;
		}
	};
	#endif

	// a group of threads shares a ticket
	// all are unlocked, once the ticket becomes active
	class OneGroupAtATimeWarp {
		uint topTicket;
		uint activeTicket;

	public:
		__device__ OneGroupAtATimeWarp() : topTicket( 1 ), activeTicket( 1 ) {}

		// returns sharedTicket if it hasn't been returned yet or is currently active
		// otherwise returns a new ticket
		// to always get a new ticket use 0 as oldTicket
		__device__ uint getUnusedTicket(uint oldTicket) {
			if( oldTicket <= activeTicket ) {
				return atomicInc( &topTicket, 0 );
			}
			return oldTicket;
		}

		__device__ void waitForTicket(uint ticket) {
			// the > makes sure, that all threads in the group get unlocked
			while( ticket > activeTicket )
				;
		}

		// return the ticket, every thread of the group can call this on its own without breaking anything
		// assert: caller is/was active
		__device__ void returnOldTicket(uint ticket) {
			atomicMax( &activeTicket, ticket + 1 );
		}

		// assert: caller's ticket == currentTicker!
		// ticket becomes inactive afterwards (for the other threads of the group, too, so call this only once!)
		__device__ void processNext() {
			// no sync needed since we are the only ones to access it
			activeTicket++;
		}
	};
}

#endif
