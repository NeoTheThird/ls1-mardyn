#include "potForce.cum"

#include "globalStats.cum"

__device__ floatType cutOffRadiusSquared;

template<class GlobalStatsCollector, class ComponentDescriptorAccessor>
struct MoleculePairHandler {
	GlobalStatsCollector &globalStatsCollector;
	ComponentDescriptorAccessor &componentDescriptorAccessor;

	__device__ MoleculePairHandler( GlobalStatsCollector &globalStatsCollector, ComponentDescriptorAccessor &componentDescriptorAccessor ) : globalStatsCollector( globalStatsCollector ), componentDescriptorAccessor( componentDescriptorAccessor ) {}

	__device__ void process( int threadIndex, Molecule &moleculeA, Molecule &moleculeB ) {
		const floatType3 distanceAtoB = moleculeB.position - moleculeA.position;
		const floatType distanceSquared = dot( distanceAtoB, distanceAtoB );

		if( distanceSquared >= cutOffRadiusSquared ) {
			return;
		}

		const ComponentDescriptor &descriptorA = componentDescriptorAccessor.get(moleculeA.componentType);
		const ComponentDescriptor &descriptorB = componentDescriptorAccessor.get(moleculeB.componentType);

		processLJCenters( threadIndex, moleculeA, moleculeB, descriptorA, descriptorB, distanceAtoB );
		processCharges( threadIndex, moleculeA, moleculeB, descriptorA, descriptorB, distanceAtoB );
	}

	__device__ void processLJCenters( int threadIndex,
			Molecule &moleculeA, Molecule &moleculeB,
			const ComponentDescriptor &descriptorA, const ComponentDescriptor &descriptorB,
			const floatType3 &distanceAtoB
		) {
#if MAX_NUM_LJCENTERS > 0
		for( int ljIndexA = 0 ; ljIndexA < descriptorA.numLJCenters ; ljIndexA++ ) {
			const ComponentDescriptor::LJCenter &ljCenterA = descriptorA.ljCenters[ljIndexA];
			const floatType3 relativePositionA = moleculeA.rotation * ljCenterA.relativePosition;

			for( int ljIndexB = 0 ; ljIndexB < descriptorB.numLJCenters ; ljIndexB++ ) {
				const ComponentDescriptor::LJCenter &ljCenterB = descriptorB.ljCenters[ljIndexB];
				const floatType3 relativePositionB = moleculeB.rotation * ljCenterB.relativePosition;

				LJParameters mixedParameters;
				// TODO: add support for eta and xi!
				mixedParameters.epsilon = sqrt( ljCenterA.ljParameters.epsilon * ljCenterB.ljParameters.epsilon );
				mixedParameters.sigma = 0.5f * (ljCenterA.ljParameters.sigma + ljCenterB.ljParameters.sigma);

				const floatType3 totalDistanceAtoB = distanceAtoB + relativePositionB - relativePositionA;
				const floatType totalDistanceSquared = dot( totalDistanceAtoB, totalDistanceAtoB );

				floatType3 forceAtoB;
				floatType potential;
				calculateLennardJones( totalDistanceAtoB, totalDistanceSquared, mixedParameters, forceAtoB, potential );

				moleculeA.force += forceAtoB;
				moleculeB.force -= forceAtoB;

				moleculeA.torque += cross( relativePositionA, forceAtoB );
				moleculeB.torque -= cross( relativePositionB, forceAtoB );

				const floatType virial = dot( distanceAtoB, forceAtoB );

				globalStatsCollector.add( threadIndex, potential, virial );
			}
		}
#endif
	}

	__device__ void processCharges( int threadIndex,
			Molecule &moleculeA, Molecule &moleculeB,
			const ComponentDescriptor &descriptorA, const ComponentDescriptor &descriptorB,
			const floatType3 &distanceAtoB
		) {
#if MAX_NUM_CHARGES > 0
		for( int chargeIndexA = 0 ; chargeIndexA < descriptorA.numCharges ; chargeIndexA++ ) {
			const ComponentDescriptor::Charge &chargeA = descriptorA.charges[chargeIndexA];
			const floatType3 relativePositionA = moleculeA.rotation * chargeA.relativePosition;

			for( int chargeIndexB = 0 ; chargeIndexB < descriptorB.numCharges ; chargeIndexB++ ) {
				const ComponentDescriptor::Charge &chargeB = descriptorB.charges[chargeIndexB];
				const floatType3 relativePositionB = moleculeB.rotation * chargeB.relativePosition;

				const float Q1Q2Per4PiE0 = chargeA.q * chargeB.q;

				const floatType3 totalDistanceAtoB = distanceAtoB + relativePositionB - relativePositionA;
				const floatType totalDistanceSquared = dot( totalDistanceAtoB, totalDistanceAtoB );

				floatType3 forceAtoB;
				floatType potential;
				calculateCharges( totalDistanceAtoB, totalDistanceSquared, Q1Q2Per4PiE0, forceAtoB, potential );

				moleculeA.force += forceAtoB;
				moleculeB.force -= forceAtoB;

				moleculeA.torque += cross( relativePositionA, forceAtoB );
				moleculeB.torque -= cross( relativePositionB, forceAtoB );

				const floatType virial = dot( distanceAtoB, forceAtoB );

				globalStatsCollector.add( threadIndex, potential, virial );
			}
		}
#endif
	}
};
