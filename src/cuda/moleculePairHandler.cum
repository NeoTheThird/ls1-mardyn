#include "potForce.cum"

#include "globalStats.cum"

__constant__ __device__ floatType cutOffRadiusSquared;
__constant__ __device__ floatType epsRFInvrc3;

template<class GlobalStatsCollector, class ComponentDescriptorAccessor>
struct MoleculePairHandler {
	GlobalStatsCollector & __restrict__ globalStatsCollector;
	ComponentDescriptorAccessor & __restrict__ componentDescriptorAccessor;

	__device__ MoleculePairHandler( GlobalStatsCollector & __restrict__ globalStatsCollector, ComponentDescriptorAccessor & __restrict__ componentDescriptorAccessor ) : globalStatsCollector( globalStatsCollector ), componentDescriptorAccessor( componentDescriptorAccessor ) {}

	__device__ __forceinline__ void process( int threadIndex, Molecule & __restrict__ moleculeA, Molecule & __restrict__ moleculeB ) {
		const floatType3 distanceAtoB = moleculeB.position - moleculeA.position;
		const floatType distanceSquared = dot( distanceAtoB, distanceAtoB );

		if( distanceSquared >= cutOffRadiusSquared ) {
			return;
		}

		const ComponentDescriptor &descriptorA = componentDescriptorAccessor.get(moleculeA.componentType);
		const ComponentDescriptor &descriptorB = componentDescriptorAccessor.get(moleculeB.componentType);

		processLJCenters( threadIndex, moleculeA, moleculeB, descriptorA, descriptorB, distanceAtoB );

		processCharges( threadIndex, moleculeA, moleculeB, descriptorA, descriptorB, distanceAtoB );

		processDipoles( threadIndex, moleculeA, moleculeB, descriptorA, descriptorB, distanceAtoB );

		processDipolesCharges( threadIndex, moleculeA, moleculeB, descriptorA, descriptorB, distanceAtoB );

		const floatType3 distanceBtoA = -distanceAtoB;
		processDipolesCharges( threadIndex, moleculeB, moleculeA, descriptorB, descriptorA, distanceBtoA );
	}

	__device__ __forceinline__ void processLJCenters( int threadIndex,
			Molecule & __restrict__ moleculeA, Molecule & __restrict__ moleculeB,
			const ComponentDescriptor &descriptorA, const ComponentDescriptor &descriptorB,
			const floatType3 & __restrict__ distanceAtoB
		) {
#if MAX_NUM_LJCENTERS > 0
		const floatType xi = componentMixXis[ moleculeA.componentType ][ moleculeB.componentType ];
		const floatType eta = componentMixEtas[ moleculeA.componentType ][ moleculeB.componentType ];

		for( int ljIndexA = 0 ; ljIndexA < MAX_NUM_LJCENTERS ; ljIndexA++ ) {
			if( ljIndexA >= descriptorA.numLJCenters ) {
				continue;
			}

			const ComponentDescriptor::LJCenter &ljCenterA = descriptorA.ljCenters[ljIndexA];
			const floatType3 relativePositionA = moleculeA.rotation * ljCenterA.relativePosition;

			for( int ljIndexB = 0 ; ljIndexB < MAX_NUM_LJCENTERS ; ljIndexB++ ) {
				if( ljIndexB >= descriptorB.numLJCenters ) {
					continue;
				}

				const ComponentDescriptor::LJCenter &ljCenterB = descriptorB.ljCenters[ljIndexB];
				const floatType3 relativePositionB = moleculeB.rotation * ljCenterB.relativePosition;

				LJParameters mixedParameters;
				// TODO: add support for eta and xi!
				mixedParameters.epsilon = xi * sqrt( ljCenterA.ljParameters.epsilon * ljCenterB.ljParameters.epsilon );
				mixedParameters.sigma = eta * 0.5f * (ljCenterA.ljParameters.sigma + ljCenterB.ljParameters.sigma);

				const floatType3 totalDistanceAtoB = distanceAtoB + relativePositionB - relativePositionA;
				const floatType totalDistanceSquared = dot( totalDistanceAtoB, totalDistanceAtoB );

				floatType3 forceAtoB;
				floatType potential;
				calculateLennardJones( totalDistanceAtoB, totalDistanceSquared, mixedParameters, forceAtoB, potential );

				moleculeA.force += forceAtoB;
				moleculeB.force -= forceAtoB;

				moleculeA.torque += cross( relativePositionA, forceAtoB );
				moleculeB.torque -= cross( relativePositionB, forceAtoB );

				const floatType virial = dot( distanceAtoB, forceAtoB );

				globalStatsCollector.add( threadIndex, potential, virial );
			}
		}
#endif
	}

	__device__ __forceinline__ void processCharges( int threadIndex,
			Molecule & __restrict__ moleculeA, Molecule & __restrict__ moleculeB,
			const ComponentDescriptor &descriptorA, const ComponentDescriptor &descriptorB,
			const floatType3 & __restrict__ distanceAtoB
		) {
#if MAX_NUM_CHARGES > 0
		for( int chargeIndexA = 0 ; chargeIndexA < MAX_NUM_CHARGES ; chargeIndexA++ ) {
			if( chargeIndexA >= descriptorA.numCharges ) {
				continue;
			}

			const ComponentDescriptor::Charge &chargeA = descriptorA.charges[chargeIndexA];
			const floatType3 relativePositionA = moleculeA.rotation * chargeA.relativePosition;

			for( int chargeIndexB = 0 ; chargeIndexB < MAX_NUM_CHARGES ; chargeIndexB++ ) {
				if( chargeIndexB >= descriptorB.numCharges ) {
					continue;
				}

				const ComponentDescriptor::Charge &chargeB = descriptorB.charges[chargeIndexB];
				const floatType3 relativePositionB = moleculeB.rotation * chargeB.relativePosition;

				const floatType3 totalDistanceAtoB = distanceAtoB + relativePositionB - relativePositionA;
				const floatType totalDistanceSquared = dot( totalDistanceAtoB, totalDistanceAtoB );

				floatType3 forceAtoB;
				floatType potential;

				const floatType Q1Q2Per4PiE0 = chargeA.q * chargeB.q;
				calculateCharges( totalDistanceAtoB, totalDistanceSquared, Q1Q2Per4PiE0, forceAtoB, potential );

				moleculeA.force += forceAtoB;
				moleculeB.force -= forceAtoB;

				moleculeA.torque += cross( relativePositionA, forceAtoB );
				moleculeB.torque -= cross( relativePositionB, forceAtoB );

				const floatType virial = dot( distanceAtoB, forceAtoB );

				globalStatsCollector.add( threadIndex, potential, virial );
			}
		}
#endif
	}

	__device__ __forceinline__ void processDipoles( int threadIndex,
				Molecule & __restrict__ moleculeA, Molecule & __restrict__ moleculeB,
				const ComponentDescriptor &descriptorA, const ComponentDescriptor &descriptorB,
				const floatType3 & __restrict__ distanceAtoB
			) {
#if MAX_NUM_DIPOLES > 0
		for( int dipoleIndexA = 0 ; dipoleIndexA < MAX_NUM_DIPOLES ; dipoleIndexA++ ) {
			if( dipoleIndexA >= descriptorA.numDipoles ) {
				continue;
			}

			const ComponentDescriptor::Dipole &dipoleA = descriptorA.dipoles[dipoleIndexA];
			const floatType3 relativePositionA = moleculeA.rotation * dipoleA.relativePosition;
			const floatType3 eA = moleculeA.rotation * dipoleA.relativeE;

			for( int dipoleIndexB = 0 ; dipoleIndexB < MAX_NUM_DIPOLES ; dipoleIndexB++ ) {
				if( dipoleIndexB >= descriptorB.numDipoles ) {
					continue;
				}

				const ComponentDescriptor::Dipole &dipoleB = descriptorB.dipoles[dipoleIndexB];
				const floatType3 relativePositionB = moleculeB.rotation * dipoleB.relativePosition;
				const floatType3 eB = moleculeB.rotation * dipoleB.relativeE;

				const floatType3 totalDistanceAtoB = distanceAtoB + relativePositionB - relativePositionA;
				const floatType totalDistanceSquared = dot( totalDistanceAtoB, totalDistanceAtoB );

				floatType3 forceAtoB;
				floatType potential;
				floatType myRF;
				floatType3 torqueA;
				floatType3 torqueB;

				const floatType my2 = dipoleA.absMy * dipoleB.absMy;
				const floatType rffac = my2 * epsRFInvrc3;
				calculateDipoleDipole( totalDistanceAtoB, totalDistanceSquared,
						eA, eB, my2, rffac, forceAtoB, potential, myRF, torqueA, torqueB );

				moleculeA.force += forceAtoB;
				moleculeB.force -= forceAtoB;

				moleculeA.torque += torqueA;
				moleculeB.torque += torqueB;

				const floatType virial = dot( distanceAtoB, forceAtoB );

				// NOTE: virial sign, so its [..] - 3. * [..] and not [..] + 3. * [..]
				globalStatsCollector.add( threadIndex, potential + myRF, virial - 3. * myRF);
			}
		}
#endif
	}

	__device__ __forceinline__ void processDipolesCharges( int threadIndex,
				Molecule & __restrict__ moleculeA, Molecule & __restrict__ moleculeB,
				const ComponentDescriptor &descriptorA, const ComponentDescriptor &descriptorB,
				const floatType3 & __restrict__ distanceAtoB
			) {
#if MAX_NUM_DIPOLES > 0 && MAX_NUM_CHARGES > 0
		// dipole as outer loop because charges are more light-weight (no rotation of e)
		for( int dipoleIndexA = 0 ; dipoleIndexA < MAX_NUM_DIPOLES ; dipoleIndexA++ ) {
			if( dipoleIndexA >= descriptorA.numDipoles ) {
				continue;
			}

			const ComponentDescriptor::Dipole &dipoleA = descriptorA.dipoles[dipoleIndexA];
			const floatType3 relativePositionA = moleculeA.rotation * dipoleA.relativePosition;
			const floatType3 eA = moleculeA.rotation * dipoleA.relativeE;

			for( int chargeIndexB = 0 ; chargeIndexB < MAX_NUM_CHARGES ; chargeIndexB++ ) {
				if( chargeIndexB >= descriptorB.numCharges ) {
					continue;
				}

				const ComponentDescriptor::Charge &chargeB = descriptorB.charges[chargeIndexB];
				const floatType3 relativePositionB = moleculeB.rotation * chargeB.relativePosition;

				const floatType3 totalDistanceAtoB = distanceAtoB + relativePositionB - relativePositionA;
				const floatType totalDistanceSquared = dot( totalDistanceAtoB, totalDistanceAtoB );

				floatType3 forceAtoB;
				floatType potential;
				floatType3 torqueA;

				const floatType qMyPer4PiE0 = dipoleA.absMy * chargeB.q;
				calculateDipoleCharge( totalDistanceAtoB, totalDistanceSquared, eA, qMyPer4PiE0, forceAtoB, potential, torqueA );

				moleculeA.force += forceAtoB;
				moleculeB.force -= forceAtoB;

				moleculeA.torque += torqueA;

				const floatType virial = dot( distanceAtoB, forceAtoB );

				globalStatsCollector.add( threadIndex, potential, virial );
			}
		}
#endif
	}
};
