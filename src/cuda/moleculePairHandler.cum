#ifndef MOLECULEPAIRHANDLER_CUM__
#define MOLECULEPAIRHANDLER_CUM__

#include "potForce.cum"

#include "globalStats.cum"
#include "componentDescriptor.cum"
#include "molecule.cum"

__constant__ __device__ floatType cutOffRadiusSquared;
__constant__ __device__ floatType epsRFInvrc3;

namespace MoleculePairHandler {
	__device__ void processLJCenters( int threadIndex,
			Molecule & __restrict__ moleculeA, Molecule & __restrict__ moleculeB,
			const ComponentDescriptor & __restrict__ descriptorA, const ComponentDescriptor & __restrict__ descriptorB,
			const floatType3 & __restrict__ distanceAtoB
		) {

		const ComponentType componentTypeA = moleculeA.getComponentType();
		const ComponentType componentTypeB = moleculeB.getComponentType();
		const floatType xi = componentMixXis[ componentTypeA ][ componentTypeB ];
		const floatType eta = componentMixEtas[ componentTypeA ][ componentTypeB ];

		for( int ljIndexA = 0 ; ljIndexA < MAX_NUM_LJCENTERS ; ljIndexA++ ) {
			if( ljIndexA >= descriptorA.numLJCenters ) {
				continue;
			}

			const ComponentDescriptor::LJCenter &ljCenterA = descriptorA.ljCenters[ljIndexA];
			const floatType3 relativePositionA = moleculeA.getRotation() * ljCenterA.relativePosition;

			for( int ljIndexB = 0 ; ljIndexB < MAX_NUM_LJCENTERS ; ljIndexB++ ) {
				if( ljIndexB >= descriptorB.numLJCenters ) {
					continue;
				}

				const ComponentDescriptor::LJCenter &ljCenterB = descriptorB.ljCenters[ljIndexB];
				const floatType3 relativePositionB = moleculeB.getRotation() * ljCenterB.relativePosition;

				LJParameters mixedParameters;
				mixedParameters.epsilon = xi * sqrt( ljCenterA.ljParameters.epsilon * ljCenterB.ljParameters.epsilon );
				mixedParameters.sigma = eta * 0.5f * (ljCenterA.ljParameters.sigma + ljCenterB.ljParameters.sigma);

				const floatType3 totalDistanceAtoB = distanceAtoB + relativePositionB - relativePositionA;

				floatType3 forceAtoB;
				floatType potential;
				calculateLennardJones( totalDistanceAtoB, mixedParameters, forceAtoB, potential );

				moleculeA.addForce( forceAtoB );
				moleculeB.addForce( -forceAtoB );

				moleculeA.addTorque( cross( relativePositionA, forceAtoB ) );
				// -cross( A, B ) = cross( B, A )
				moleculeB.addTorque( cross( forceAtoB, relativePositionB ) );

				const floatType virial = dot( distanceAtoB, forceAtoB );

				ThreadBlockCellStats::add( threadIndex, potential, virial );
			}
		}
	}

#if MAX_NUM_CHARGES > 0
	__device__ void processCharges( int threadIndex,
			Molecule & __restrict__ moleculeA, Molecule & __restrict__ moleculeB,
			const ComponentDescriptor & __restrict__ descriptorA, const ComponentDescriptor & __restrict__ descriptorB,
			const floatType3 & __restrict__ distanceAtoB
		) {
		for( int chargeIndexA = 0 ; chargeIndexA < MAX_NUM_CHARGES ; chargeIndexA++ ) {
			if( chargeIndexA >= descriptorA.numCharges ) {
				continue;
			}

			const ComponentDescriptor::Charge &chargeA = descriptorA.charges[chargeIndexA];
			const floatType3 relativePositionA = moleculeA.getRotation() * chargeA.relativePosition;

			for( int chargeIndexB = 0 ; chargeIndexB < MAX_NUM_CHARGES ; chargeIndexB++ ) {
				if( chargeIndexB >= descriptorB.numCharges ) {
					continue;
				}

				const ComponentDescriptor::Charge &chargeB = descriptorB.charges[chargeIndexB];
				const floatType3 relativePositionB = moleculeB.getRotation() * chargeB.relativePosition;

				const floatType3 totalDistanceAtoB = distanceAtoB + relativePositionB - relativePositionA;
				const floatType totalDistanceSquared = dot( totalDistanceAtoB, totalDistanceAtoB );

				floatType3 forceAtoB;
				floatType potential;

				const floatType Q1Q2Per4PiE0 = chargeA.q * chargeB.q;
				calculateCharges( totalDistanceAtoB, totalDistanceSquared, Q1Q2Per4PiE0, forceAtoB, potential );

				moleculeA.addForce( forceAtoB );
				moleculeB.addForce( -forceAtoB );

				moleculeA.addTorque( cross( relativePositionA, forceAtoB ) );
				moleculeB.addTorque( cross( forceAtoB, relativePositionB ) );

				const floatType virial = dot( distanceAtoB, forceAtoB );

				ThreadBlockCellStats::add( threadIndex, potential, virial );
			}
		}
	}
#endif

#if MAX_NUM_DIPOLES > 0
	__device__ void processDipoles( int threadIndex,
				Molecule & __restrict__ moleculeA, Molecule & __restrict__ moleculeB,
				const ComponentDescriptor & __restrict__ descriptorA, const ComponentDescriptor & __restrict__ descriptorB,
				const floatType3 & __restrict__ distanceAtoB
			) {
		for( int dipoleIndexA = 0 ; dipoleIndexA < MAX_NUM_DIPOLES ; dipoleIndexA++ ) {
			if( dipoleIndexA >= descriptorA.numDipoles ) {
				continue;
			}

			const ComponentDescriptor::Dipole &dipoleA = descriptorA.dipoles[dipoleIndexA];
			const Matrix3x3 rotationA = moleculeA.getRotation();
			const floatType3 relativePositionA = rotationA * dipoleA.relativePosition;
			const floatType3 eA = rotationA * dipoleA.relativeE;

			for( int dipoleIndexB = 0 ; dipoleIndexB < MAX_NUM_DIPOLES ; dipoleIndexB++ ) {
				if( dipoleIndexB >= descriptorB.numDipoles ) {
					continue;
				}

				const ComponentDescriptor::Dipole &dipoleB = descriptorB.dipoles[dipoleIndexB];
				const Matrix3x3 rotationB = moleculeB.getRotation();
				const floatType3 relativePositionB = rotationB * dipoleB.relativePosition;
				const floatType3 eB = rotationB * dipoleB.relativeE;

				const floatType3 totalDistanceAtoB = distanceAtoB + relativePositionB - relativePositionA;
				const floatType totalDistanceSquared = dot( totalDistanceAtoB, totalDistanceAtoB );

				floatType3 forceAtoB;
				floatType potential;
				floatType myRF;
				floatType3 torqueA;
				floatType3 torqueB;

				const floatType my2 = dipoleA.absMu * dipoleB.absMu;
				const floatType rffac = my2 * epsRFInvrc3;
				calculateDipoleDipole( totalDistanceAtoB, totalDistanceSquared,
						eA, eB, my2, rffac, forceAtoB, potential, myRF, torqueA, torqueB );

				moleculeA.addForce( forceAtoB );
				moleculeB.addForce( -forceAtoB );

				moleculeA.addTorque( torqueA );
				moleculeB.addTorque( torqueB );

				const floatType virial = dot( distanceAtoB, forceAtoB );

				// NOTE: virial sign, so its [..] - 3. * [..] and not [..] + 3. * [..]
				ThreadBlockCellStats::add( threadIndex, potential + myRF, virial - 3. * myRF);
			}
		}
	}
#endif

#if MAX_NUM_DIPOLES > 0 && MAX_NUM_CHARGES > 0
	__device__ void processDipolesCharges( int threadIndex,
				Molecule & __restrict__ moleculeA, Molecule & __restrict__ moleculeB,
				const ComponentDescriptor & __restrict__ descriptorA, const ComponentDescriptor & __restrict__ descriptorB,
				const floatType3 & __restrict__ distanceAtoB
			) {
		// dipole as outer loop because charges are more light-weight (no rotation of e)
		for( int dipoleIndexA = 0 ; dipoleIndexA < MAX_NUM_DIPOLES ; dipoleIndexA++ ) {
			if( dipoleIndexA >= descriptorA.numDipoles ) {
				continue;
			}

			const ComponentDescriptor::Dipole &dipoleA = descriptorA.dipoles[dipoleIndexA];
			const Matrix3x3 rotationA = moleculeA.getRotation();
			const floatType3 relativePositionA = rotationA * dipoleA.relativePosition;
			const floatType3 eA = rotationA * dipoleA.relativeE;

			for( int chargeIndexB = 0 ; chargeIndexB < MAX_NUM_CHARGES ; chargeIndexB++ ) {
				if( chargeIndexB >= descriptorB.numCharges ) {
					continue;
				}

				const ComponentDescriptor::Charge &chargeB = descriptorB.charges[chargeIndexB];
				const floatType3 relativePositionB = moleculeB.getRotation() * chargeB.relativePosition;

				const floatType3 totalDistanceAtoB = distanceAtoB + relativePositionB - relativePositionA;
				const floatType totalDistanceSquared = dot( totalDistanceAtoB, totalDistanceAtoB );

				floatType3 forceAtoB;
				floatType potential;
				floatType3 torqueA;

				const floatType qMyPer4PiE0 = dipoleA.absMu * chargeB.q;
				calculateDipoleCharge( totalDistanceAtoB, totalDistanceSquared, eA, qMyPer4PiE0, forceAtoB, potential, torqueA );

				moleculeA.addForce( forceAtoB );
				moleculeB.addForce( -forceAtoB );

				moleculeA.addTorque( torqueA );

				const floatType virial = dot( distanceAtoB, forceAtoB );

				ThreadBlockCellStats::add( threadIndex, potential, virial );
			}
		}
	}
#endif

#if MAX_NUM_QUADRUPOLES > 0
	__device__ void processQuadrupoles( int threadIndex,
				Molecule & __restrict__ moleculeA, Molecule & __restrict__ moleculeB,
				const ComponentDescriptor & __restrict__ descriptorA, const ComponentDescriptor & __restrict__ descriptorB,
				const floatType3 & __restrict__ distanceAtoB
			) {
		for( int indexA = 0 ; indexA < MAX_NUM_QUADRUPOLES ; indexA++ ) {
			if( indexA >= descriptorA.numQuadrupoles ) {
				continue;
			}

			const ComponentDescriptor::Quadrupole &quadrupoleA = descriptorA.quadrupoles[indexA];
			const Matrix3x3 rotationA = moleculeA.getRotation();
			const floatType3 relativePositionA = rotationA * quadrupoleA.relativePosition;
			const floatType3 eA = rotationA * quadrupoleA.relativeE;

			for( int indexB = 0 ; indexB < MAX_NUM_QUADRUPOLES ; indexB++ ) {
				if( indexB >= descriptorB.numQuadrupoles ) {
					continue;
				}

				const ComponentDescriptor::Quadrupole &quadrupoleB = descriptorB.quadrupoles[indexB];
				const Matrix3x3 rotationB = moleculeB.getRotation();
				const floatType3 relativePositionB = rotationB * quadrupoleB.relativePosition;
				const floatType3 eB = rotationB * quadrupoleB.relativeE;

				const floatType3 totalDistanceAtoB = distanceAtoB + relativePositionB - relativePositionA;
				const floatType totalDistanceSquared = dot( totalDistanceAtoB, totalDistanceAtoB );

				floatType3 forceAtoB;
				floatType potential;
				floatType3 torqueA;
				floatType3 torqueB;

				const floatType q2075 = 0.75 * quadrupoleA.absQ * quadrupoleB.absQ;

				calculateQuadrupoleQuardrupole( totalDistanceAtoB, totalDistanceSquared,
						eA, eB, q2075, forceAtoB, torqueA, torqueB, potential );

				moleculeA.addForce( forceAtoB );
				moleculeB.addForce( -forceAtoB );

				moleculeA.addTorque( torqueA );
				moleculeB.addTorque( torqueB );

				const floatType virial = dot( distanceAtoB, forceAtoB );

				ThreadBlockCellStats::add( threadIndex, potential, virial );
			}
		}
	}
#endif

#if MAX_NUM_QUADRUPOLES > 0 && MAX_NUM_DIPOLES > 0
	__device__ void processDipolesQuadrupoles( int threadIndex,
				Molecule & __restrict__ moleculeA, Molecule & __restrict__ moleculeB,
				const ComponentDescriptor & __restrict__ descriptorA, const ComponentDescriptor & __restrict__ descriptorB,
				const floatType3 & __restrict__ distanceAtoB
			) {
		// dipole as outer loop because charges are more light-weight (no rotation of e)
		for( int dipoleIndexA = 0 ; dipoleIndexA < MAX_NUM_DIPOLES ; dipoleIndexA++ ) {
			if( dipoleIndexA >= descriptorA.numDipoles ) {
				continue;
			}

			const ComponentDescriptor::Dipole &dipoleA = descriptorA.dipoles[dipoleIndexA];
			const Matrix3x3 rotationA = moleculeA.getRotation();
			const floatType3 relativePositionA = rotationA * dipoleA.relativePosition;
			const floatType3 eA = rotationA * dipoleA.relativeE;

			for( int quadrupoleIndexB = 0 ; quadrupoleIndexB < MAX_NUM_QUADRUPOLES ; quadrupoleIndexB++ ) {
				if( quadrupoleIndexB >= descriptorB.numQuadrupoles ) {
					continue;
				}

				const ComponentDescriptor::Quadrupole &quadrupoleB = descriptorB.quadrupoles[quadrupoleIndexB];
				const Matrix3x3 rotationB = moleculeB.getRotation();
				const floatType3 relativePositionB = rotationB * quadrupoleB.relativePosition;
				const floatType3 eB = rotationB * quadrupoleB.relativeE;

				const floatType3 totalDistanceAtoB = distanceAtoB + relativePositionB - relativePositionA;
				const floatType totalDistanceSquared = dot( totalDistanceAtoB, totalDistanceAtoB );

				floatType3 forceAtoB;
				floatType potential;
				floatType3 torqueA;
				floatType3 torqueB;

				const floatType qMy15 = 1.5 * quadrupoleB.absQ * dipoleA.absMu;
				calculateDipoleQuadrupole( totalDistanceAtoB, totalDistanceSquared,
						eA, eB, qMy15, forceAtoB, torqueA, torqueB, potential );

				moleculeA.addForce( forceAtoB );
				moleculeB.addForce( -forceAtoB );

				moleculeA.addTorque( torqueA );
				moleculeB.addTorque( torqueB );

				const floatType virial = dot( distanceAtoB, forceAtoB );

				ThreadBlockCellStats::add( threadIndex, potential, virial );
			}
		}
	}
#endif

#if MAX_NUM_QUADRUPOLES > 0 && MAX_NUM_CHARGES > 0
	__device__ void processQuadrupolesCharges( int threadIndex,
				Molecule & __restrict__ moleculeA, Molecule & __restrict__ moleculeB,
				const ComponentDescriptor & __restrict__ descriptorA, const ComponentDescriptor & __restrict__ descriptorB,
				const floatType3 & __restrict__ distanceAtoB
			) {
		// dipole as outer loop because charges are more light-weight (no rotation of e)
		for( int quadrupoleIndexA = 0 ; quadrupoleIndexA < MAX_NUM_QUADRUPOLES ; quadrupoleIndexA++ ) {
			if( quadrupoleIndexA >= descriptorA.numQuadrupoles ) {
				continue;
			}

			const ComponentDescriptor::Quadrupole &quadrupoleA = descriptorA.quadrupoles[quadrupoleIndexA];
			const Matrix3x3 rotationA = moleculeA.getRotation();
			const floatType3 relativePositionA = rotationA * quadrupoleA.relativePosition;
			const floatType3 eA = rotationA * quadrupoleA.relativeE;

			for( int chargeIndexB = 0 ; chargeIndexB < MAX_NUM_CHARGES ; chargeIndexB++ ) {
				if( chargeIndexB >= descriptorB.numCharges ) {
					continue;
				}

				const ComponentDescriptor::Charge &chargeB = descriptorB.charges[chargeIndexB];
				const floatType3 relativePositionB = moleculeB.getRotation() * chargeB.relativePosition;

				const floatType3 totalDistanceAtoB = distanceAtoB + relativePositionB - relativePositionA;
				const floatType totalDistanceSquared = dot( totalDistanceAtoB, totalDistanceAtoB );

				floatType3 forceBtoA;
				floatType potential;
				floatType3 torqueA;

				const floatType qMy025Per4PiE0 = 0.25 * quadrupoleA.absQ * chargeB.q;
				// NOTE: -totalDistanceAtoB because A is the quadrupole and B is the charge and not vice-versa
				calculateChargeQuadrupole( -totalDistanceAtoB, totalDistanceSquared, eA, qMy025Per4PiE0, forceBtoA, torqueA, potential );

				moleculeA.addForce( -forceBtoA );
				moleculeB.addForce( forceBtoA );

				moleculeA.addTorque( torqueA );

				// NOTE: -dot(...) for the same reason as above
				const floatType virial = -dot( distanceAtoB, forceBtoA );

				ThreadBlockCellStats::add( threadIndex, potential, virial );
			}
		}
	}
#endif

	__device__ void process( int threadIndex, Molecule & __restrict__ moleculeA, Molecule & __restrict__ moleculeB ) {
		const floatType3 distanceAtoB = moleculeB.getPosition() - moleculeA.getPosition();
		const floatType distanceSquared = dot( distanceAtoB, distanceAtoB );

		if( distanceSquared >= cutOffRadiusSquared ) {
			return;
		}

		const ComponentDescriptor &descriptorA = componentDescriptors[moleculeA.getComponentType()];
		const ComponentDescriptor &descriptorB = componentDescriptors[moleculeB.getComponentType()];
#if MAX_NUM_LJCENTERS > 0
		processLJCenters( threadIndex, moleculeA, moleculeB, descriptorA, descriptorB, distanceAtoB );
#endif
#if MAX_NUM_CHARGES > 0
		processCharges( threadIndex, moleculeA, moleculeB, descriptorA, descriptorB, distanceAtoB );
#endif
#if MAX_NUM_DIPOLES > 0
		processDipoles( threadIndex, moleculeA, moleculeB, descriptorA, descriptorB, distanceAtoB );
#endif
#if MAX_NUM_DIPOLES > 0 && MAX_NUM_CHARGES > 0
		processDipolesCharges( threadIndex, moleculeA, moleculeB, descriptorA, descriptorB, distanceAtoB );
		processDipolesCharges( threadIndex, moleculeB, moleculeA, descriptorB, descriptorA, -distanceAtoB );
#endif

#if MAX_NUM_QUADRUPOLES > 0
		processQuadrupoles( threadIndex, moleculeA, moleculeB, descriptorA, descriptorB, distanceAtoB );

#if MAX_NUM_CHARGES > 0
		processQuadrupolesCharges( threadIndex, moleculeA, moleculeB, descriptorA, descriptorB, distanceAtoB );
		processQuadrupolesCharges( threadIndex, moleculeB, moleculeA, descriptorB, descriptorA, -distanceAtoB );
#endif

#if MAX_NUM_DIPOLES > 0
		processDipolesQuadrupoles( threadIndex, moleculeA, moleculeB, descriptorA, descriptorB, distanceAtoB );
		processDipolesQuadrupoles( threadIndex, moleculeB, moleculeA, descriptorB, descriptorA, -distanceAtoB );
#endif
#endif
	}
};

#endif
