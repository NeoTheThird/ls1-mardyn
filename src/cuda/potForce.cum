#ifndef POTFORCE_CUM__
#define POTFORCE_CUM__

#include <host_defines.h>

#include "cutil_math.h"

#include "sharedDecls.h"

__device__ void calculateLennardJones( const floatType3 &distanceAtoB, const floatType distanceSquared, const LJParameters &ljParameters,
		floatType3 &forceAtoB, floatType &potential) {
	const floatType invdr2 = 1. / distanceSquared;
	const floatType lj2 = ljParameters.sigma * ljParameters.sigma * invdr2;
	const floatType lj6 = lj2 * lj2 * lj2;
	const floatType lj12 = lj6 * lj6;
	const floatType lj12m6 = lj12 - lj6;
	potential = 4.0f * ljParameters.epsilon * lj12m6;
	// result: force = fac * distance = fac * |distance| * normalized(distance)
	// - sign because the force is repulsive
	forceAtoB = -24.0f * ljParameters.epsilon * (lj12 + lj12m6) * invdr2 * distanceAtoB;
}

__device__ void calculateCharges( const floatType3 &distanceAtoB, const floatType distanceSquared, const floatType &Q1Q2Per4PiE0,
		floatType3 &forceAtoB, floatType &potential) {
	const floatType invdr2 = 1. / distanceSquared;
	const floatType invdr = rsqrt( distanceSquared );
	potential = Q1Q2Per4PiE0 * invdr;
	// - because the force is repulsive
	forceAtoB = -potential * invdr2 * distanceAtoB;
}

__device__ void calculateDipoleCharge( const floatType3 &distanceAtoB, const floatType distanceSquared, const floatType3 &eA, const floatType qMyPer4PiE0,
		floatType3 &forceAtoB, floatType &potential, floatType3 &torqueA ) {
	const floatType invdr2 = 1. / distanceSquared;
	const floatType invdr = rsqrt( distanceSquared );

	const floatType uInvcostA = -qMyPer4PiE0 * invdr2;
	potential = uInvcostA * dot( eA, distanceAtoB ) * invdr;

	const floatType partialTAInvdr1 = uInvcostA * invdr;

	forceAtoB = partialTAInvdr1 * eA - 3.0 * potential * invdr * invdr2 * distanceAtoB;

	torqueA = partialTAInvdr1 * cross( distanceAtoB, eA );
}

__device__ void calculateDipoleDipole( const floatType3 &distanceAtoB, const floatType distanceSquared, const floatType3 &eA, const floatType3 &eB, const floatType my2, const floatType rffac,
		floatType3 &forceAtoB, floatType &potential, floatType &myRF, floatType3 &torqueA, floatType3 &torqueB ) {
	const floatType invdr2 = 1. / distanceSquared;
	const floatType invdr = sqrt( invdr2 );

	const floatType partialGAB = -my2 * invdr2 * invdr;

	const floatType costA = dot( eA, distanceAtoB ) * invdr;
	const floatType costB = dot( eB, distanceAtoB ) * invdr;
	const floatType cosgAB = dot( eA, eB );
	potential = partialGAB * (3. * costA * costB - cosgAB);
	myRF = -rffac * cosgAB;

	const floatType partialRABInvdr = 3. * potential * invdr2;
	const floatType partialTAInvdr = partialGAB * 3. * costB * invdr;
	const floatType partialTBInvdr = partialGAB * 3. * costA * invdr;

	const floatType fac = partialRABInvdr + (costA * partialTAInvdr + costB * partialTBInvdr) * invdr;
	forceAtoB = partialTAInvdr * eA + partialTBInvdr * eB - fac * distanceAtoB;

	const floatType3 eAxeB = (rffac + partialGAB) * cross( eA, eB );
	torqueA = partialTAInvdr * cross( distanceAtoB, eA ) + eAxeB;
	torqueB = partialTBInvdr * cross( distanceAtoB, eB ) - eAxeB;
}

#endif
