#ifndef POTFORCE_CUM__
#define POTFORCE_CUM__

#include <host_defines.h>

#include "cutil_math.h"

#include "sharedDecls.h"

static __device__ void calculateLennardJones(
		const floatType3 & __restrict__ distanceAtoB,
		const LJParameters & __restrict__ ljParameters,
		floatType3 & __restrict__ forceAtoB, floatType & __restrict__ potential
	) {
	const floatType invdr2 = 1. / dot( distanceAtoB, distanceAtoB );
	const floatType lj2 = ljParameters.sigma * ljParameters.sigma * invdr2;
	const floatType lj6 = lj2 * lj2 * lj2;
	const floatType lj12 = lj6 * lj6;
	const floatType lj12m6 = lj12 - lj6;
	potential = 4.0f * ljParameters.epsilon * lj12m6;
	// result: force = fac * distance = fac * |distance| * normalized(distance)
	// - sign because the force is repulsive
	forceAtoB = -24.0f * ljParameters.epsilon * (lj12 + lj12m6) * invdr2 * distanceAtoB;
}

static __device__ void calculateCharges(
		const floatType3 & __restrict__ distanceAtoB, const floatType distanceSquared,
		const floatType & __restrict__ Q1Q2Per4PiE0,
		floatType3 & __restrict__ forceAtoB, floatType & __restrict__ potential
	) {
	const floatType invdr2 = 1. / distanceSquared;
	const floatType invdr = rsqrt( distanceSquared );
	potential = Q1Q2Per4PiE0 * invdr;
	// - because the force is repulsive
	forceAtoB = -potential * invdr2 * distanceAtoB;
}

static __device__ void calculateDipoleCharge(
		const floatType3 & __restrict__ distanceAtoB, const floatType distanceSquared,
		const floatType3 & __restrict__ eA, const floatType qMyPer4PiE0,
		floatType3 & __restrict__ forceAtoB,
		floatType & __restrict__ potential, floatType3 & __restrict__ torqueA
	) {
	const floatType invdr2 = 1. / distanceSquared;
	const floatType invdr = rsqrt( distanceSquared );

	const floatType uInvcostA = -qMyPer4PiE0 * invdr2;
	potential = uInvcostA * dot( eA, distanceAtoB ) * invdr;

	const floatType partialTAInvdr1 = uInvcostA * invdr;

	forceAtoB = partialTAInvdr1 * eA - 3.0 * potential * invdr * invdr2 * distanceAtoB;

	torqueA = partialTAInvdr1 * cross( distanceAtoB, eA );
}

static __device__ void calculateDipoleDipole(
		const floatType3 & __restrict__ distanceAtoB, const floatType distanceSquared,
		const floatType3 & __restrict__ eA, const floatType3 & __restrict__ eB,
		const floatType my2, const floatType rffac,
		floatType3 & __restrict__ forceAtoB,
		floatType & __restrict__ potential, floatType & __restrict__ myRF,
		floatType3 & __restrict__ torqueA, floatType3 & __restrict__ torqueB
	) {
	const floatType invdr2 = 1.0 / distanceSquared;
	const floatType invdr = sqrt( invdr2 );

	const floatType partialGAB = -my2 * invdr2 * invdr;

	const floatType costA = dot( eA, distanceAtoB ) * invdr;
	const floatType costB = dot( eB, distanceAtoB ) * invdr;
	const floatType cosgAB = dot( eA, eB );
	potential = partialGAB * (3. * costA * costB - cosgAB);
	myRF = -rffac * cosgAB;

	const floatType partialRABInvdr = 3. * potential * invdr2;
	const floatType partialTAInvdr = partialGAB * 3. * costB * invdr;
	const floatType partialTBInvdr = partialGAB * 3. * costA * invdr;

	const floatType fac = partialRABInvdr + (costA * partialTAInvdr + costB * partialTBInvdr) * invdr;
	forceAtoB = partialTAInvdr * eA + partialTBInvdr * eB - fac * distanceAtoB;

	const floatType3 eAxeB = (rffac + partialGAB) * cross( eA, eB );
	torqueA = partialTAInvdr * cross( distanceAtoB, eA ) + eAxeB;
	torqueB = partialTBInvdr * cross( distanceAtoB, eB ) - eAxeB;
}

#endif
