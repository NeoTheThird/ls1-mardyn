#ifndef POTFORCE_CUM__
#define POTFORCE_CUM__

#include <host_defines.h>

#include "cutil_math.h"

#include "sharedDecls.h"

__device__ void calculateLennardJones( const floatType3 &distanceAtoB, const floatType distanceSquared, const LJParameters &ljParameters,
		floatType3 &forceAtoB, floatType &potential) {
	const floatType invdr2 = 1. / distanceSquared;
	const floatType lj2 = ljParameters.sigma * ljParameters.sigma * invdr2;
	const floatType lj6 = lj2 * lj2 * lj2;
	const floatType lj12 = lj6 * lj6;
	const floatType lj12m6 = lj12 - lj6;
	potential = 4.0f * ljParameters.epsilon * lj12m6;
	// result: force = fac * distance = fac * |distance| * normalized(distance)
	// - sign because the force is repulsive
	forceAtoB = -24.0f * ljParameters.epsilon * (lj12 + lj12m6) * invdr2 * distanceAtoB;
}

__device__ void calculateCharges( const floatType3 &distanceAtoB, const floatType distanceSquared, const floatType &Q1Q2Per4PiE0,
		floatType3 &forceAtoB, floatType &potential) {
	const floatType invdr2 = 1. / distanceSquared;
	const floatType invdr = rsqrt( distanceSquared );
	potential = Q1Q2Per4PiE0 * invdr;
	// - because the force is repulsive
	forceAtoB = -potential * invdr2 * distanceAtoB;
}

__device__ void calculateChargeDipole( const floatType3 &distanceAtoB, const floatType distanceSquared, const floatType3 &eB, const floatType minusQMyPer4PiE0,
		floatType3 &forceAtoB, floatType &potential, floatType3 &torqueB ) {
	const floatType invdr2 = 1. / distanceSquared;
	const floatType invdr = rsqrt( distanceSquared );

	const floatType uInvcostB = minusQMyPer4PiE0 * invdr2;
	potential = uInvcostB * dot( eB, distanceAtoB ) * invdr;
	const floatType partialTBInvdr1 = uInvcostB * invdr;

	forceAtoB = partialTBInvdr1 * eB - 3.0 * potential * invdr * invdr2 * distanceAtoB;

	torqueB = partialTBInvdr1 * cross( distanceAtoB, eB );
}

__device__ void calculateDipoleDipole( const floatType3 &distanceAtoB, const floatType distanceSquared, const floatType3 &eA, const floatType3 &eB, const floatType my2, const floatType rffac,
		floatType3 &forceAtoB, floatType &potential, floatType3 &torqueA, floatType3 &torqueB ) {
	const floatType invdr2 = 1. / distanceSquared;
	const floatType invdr = rsqrt( distanceSquared );

	const floatType partialGAB = my2 * invdr2 * invdr;

	const floatType costA = dot( eA, distanceAtoB ) * invdr;
	const floatType costB = dot( eB, distanceAtoB ) * invdr;
	const floatType cosgAB = dot( eA, eB );
	potential = partialGAB * ( cosgAB - 3. * costA * costB );
	// MyRF missing here

	const floatType partialABInvdr = -3. * potential * invdr2;
	const floatType partialAInvdr = -partialGAB * 3. * costB * invdr;
	const floatType partialBInvdr = -partialGAB * 3. * costA * invdr;

	const floatType fac = -partialABInvdr + (costA * partialAInvdr + costB * partialBInvdr) * invdr;
	forceAtoB = partialAInvdr * eA + partialBInvdr * eB - fac * distanceAtoB;

	const floatType3 eAxeB = (rffac - partialGAB) * cross( eA, eB );
	torqueA = -partialAInvdr * cross( eA, distanceAtoB ) + eAxeB;
	torqueB = -partialBInvdr * cross( eB, distanceAtoB ) - eAxeB;
}

#endif
