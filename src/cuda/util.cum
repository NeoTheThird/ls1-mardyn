#ifndef UTIL_CUM__
#define UTIL_CUM__

#include <host_defines.h>

#include "sharedDecls.h"

struct Matrix3x3 : Matrix3x3Storage {
	__device__ inline floatType3 operator *(const floatType3 & __restrict__ vector) const {
		return make_floatType3( dot( rows[0], vector ), dot( rows[1], vector ), dot( rows[2], vector ) );
	}
};

struct Quaternion : QuaternionStorage {
	/* according to http://www.flipcode.com/documents/matrfaq.html#Q54
	 * this is the standard quaternion to matrix conversion (not the inverse one!)
	 */
	__device__ inline Matrix3x3 toRotMatrix3x3() const {
		Matrix3x3 rot;

		const floatType ww=w*w;
		const floatType xx=x*x;
		const floatType yy=y*y;
		const floatType zz=z*z;
		const floatType xy=x*y;
		const floatType zw=z*w;
		const floatType xz=x*z;
		const floatType yw=y*w;
		const floatType yz=y*z;
		const floatType xw=x*w;

		rot.rows[0].x=ww+xx-yy-zz;
		rot.rows[0].y=2*(xy-zw);
		rot.rows[0].z=2*(xz+yw);

		rot.rows[1].x=2*(xy+zw);
		rot.rows[1].y=ww-xx+yy-zz;
		rot.rows[1].z=2*(yz-xw);

		rot.rows[2].x=2*(xz-yw);
		rot.rows[2].y=2*(yz+xw);
		rot.rows[2].z=ww-xx-yy+zz;

		return rot;
	}
};

template<typename DataType>
__device__ floatType3 packFloatType3( const DataType *unpacked, uint index ) {
	return make_floatType3( unpacked[0][index], unpacked[1][index], unpacked[2][index] );
}

template<typename DataType>
__device__ void unpackFloatType3( DataType *unpacked, uint index, const floatType3 &packed ) {
	unpacked[0][index] = packed.x;
	unpacked[1][index] = packed.y;
	unpacked[2][index] = packed.z;
}

template<typename DataType>
__device__ Matrix3x3 packMatrix3x3( const DataType *unpacked, uint index ) {
	Matrix3x3 mat;
	mat.rows[0] = packFloatType3( unpacked + 0, index );
	mat.rows[1] = packFloatType3( unpacked + 3, index );
	mat.rows[2] = packFloatType3( unpacked + 6, index );
	return mat;
}

template<typename DataType>
__device__ void unpackMatrix3x3( DataType *unpacked, uint index, const Matrix3x3 &packed ) {
	unpackFloatType3( unpacked + 0, index, packed.rows[0] );
	unpackFloatType3( unpacked + 3, index, packed.rows[1] );
	unpackFloatType3( unpacked + 6, index, packed.rows[2] );
}

template<typename DataType>
__device__ Quaternion packQuaternion( const DataType *unpacked, uint index ) {
	Quaternion quat;
	quat.w = unpacked[0][index];
	quat.x = unpacked[1][index];
	quat.y = unpacked[2][index];
	quat.z = unpacked[3][index];
	return quat;
}

// = ceil( a / b )
template< typename IntType >
__device__ inline IntType iceil(IntType a, IntType b) {
	return (a + b - 1) / b;
}

// = b if a % b = 0, a % b otherwise
template< typename IntType >
__device__ inline IntType shiftedMod( IntType a, IntType b ) {
	int r = a % b;
	return (r > 0) ? r : b;
}

__device__ double atomicAdd(double *address, double val) {
	unsigned long long int *ull_address = (unsigned long long int*) address;
	unsigned long long int old = *ull_address;
	unsigned long long int assumed;

	do {
		assumed = old;
		old = atomicCAS( ull_address, assumed, __double_as_longlong(val + __longlong_as_double(assumed)) );
	} while( assumed != old );

	return __longlong_as_double( old );
}

#endif
