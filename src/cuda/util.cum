#ifndef UTIL_CUM
#define UTIL_CUM
#include <host_defines.h>

#include "sharedDecls.h"

struct Matrix3x3 : Matrix3x3Storage {
	__device__ inline floatType3 operator *(const floatType3 & __restrict__ vector) const {
		return make_floatType3( dot( rows[0], vector ), dot( rows[1], vector ), dot( rows[2], vector ) );
	}
};

struct Quaternion : QuaternionStorage {
	/* according to http://www.flipcode.com/documents/matrfaq.html#Q54
	 * this is the standard quaternion to matrix conversion (not the inverse one!)
	 */
	__device__ inline Matrix3x3 toRotMatrix3x3() const {
		Matrix3x3 rot;

		const floatType ww=w*w;
		const floatType xx=x*x;
		const floatType yy=y*y;
		const floatType zz=z*z;
		const floatType xy=x*y;
		const floatType zw=z*w;
		const floatType xz=x*z;
		const floatType yw=y*w;
		const floatType yz=y*z;
		const floatType xw=x*w;

		rot.rows[0].x=ww+xx-yy-zz;
		rot.rows[0].y=2*(xy-zw);
		rot.rows[0].z=2*(xz+yw);

		rot.rows[1].x=2*(xy+zw);
		rot.rows[1].y=ww-xx+yy-zz;
		rot.rows[1].z=2*(yz-xw);

		rot.rows[2].x=2*(xz-yw);
		rot.rows[2].y=2*(yz+xw);
		rot.rows[2].z=ww-xx-yy+zz;

		return rot;
	}
};

// = ceil( a / b )
template< typename IntType >
__device__ inline IntType iceil(IntType a, IntType b) {
	return (a + b - 1) / b;
}

// = b if a % b = 0, a % b otherwise
template< typename IntType >
__device__ inline IntType shiftedMod( IntType a, IntType b ) {
	int r = a % b;
	return (r > 0) ? r : b;
}

#endif
