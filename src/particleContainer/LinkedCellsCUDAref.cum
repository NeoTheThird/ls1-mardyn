#include "cutil_math.h"

#define WARP_SIZE 1
#define NUM_WARPS 1
#define BLOCK_SIZE (WARP_SIZE*NUM_WARPS)

// threadIdx.xy = intraWarpIndex | warpIndex

__device__ inline void calculateInteraction(
		const CUDAPrecisionType cutOffRadiusSquared,
		const ComponentLJCenterInfo &componentLJCenterInfo,
		const CUDAPrecisionType3 &positionA, const CUDAPrecisionType3 &positionB,
		CUDAPrecisionType3 &forceA, CUDAPrecisionType3 &forceB,
		CUDAPrecisionType &totalPotential, CUDAPrecisionType &totalVirial
	) {
	const CUDAPrecisionType3 distance = positionB - positionA;
	const CUDAPrecisionType distanceSquared = dot( distance, distance );

	if( distanceSquared >= cutOffRadiusSquared ) {
		return;
	}

	CUDAPrecisionType3 force;
	CUDAPrecisionType potential;
	calculateLennardJones( distance, distanceSquared, componentLJCenterInfo.epsilon, componentLJCenterInfo.sigmaSquared, force, potential );

	totalPotential += potential;
	CUDAPrecisionType virial = dot( force, distance );
	totalVirial += virial;

	forceA += force;
	forceB -= force;
}

__global__ void Kernel_calculatePairLJForces(
		const CUDAPrecisionType3 *positions, const unsigned char *componentLJCenterIndices, CUDAPrecisionType3 *forces,
		const ComponentLJCenterInfo *componentLJCenterInfos, int numComponentLJCenters,
		const int *cellInfos, float2 *domainValues,
		int startIndex, int2 dimension, int3 gridOffsets, int neighborOffset,
		CUDAPrecisionType cutOffRadiusSquared ) {

	int cellIndex = getCellIndex( startIndex, dimension, gridOffsets );
	int neighborIndex = cellIndex + neighborOffset;
	int cellLength = cellInfos[ cellIndex + 1 ] - cellInfos[ cellIndex ];
	int neighborLength = cellInfos[ neighborIndex + 1 ] - cellInfos[ neighborIndex ];

	// ensure that cellA_length <= cellB_length (which will use fewer data transfers)
	// (numTransfersA + numTransfersA * numTransfersB) * BLOCK_SIZE
	if( cellLength > neighborLength ) {
		// swap cellIndex and neighborIndex
		cellIndex = neighborIndex;
		neighborIndex -= neighborOffset;
	}

	const int cellAStart = cellInfos[cellIndex];
	const int cellALength = cellInfos[cellIndex + 1] - cellAStart;
	const int cellBStart = cellInfos[neighborIndex];
	const int cellBLength = cellInfos[neighborIndex + 1] - cellBStart;

	CUDAPrecisionType totalPotential = 0.0f;
	CUDAPrecisionType totalVirial = 0.0f;

	const CUDAPrecisionType3 *positionsA = positions + cellAStart;
	const CUDAPrecisionType3 *positionsB = positions + cellBStart;

	CUDAPrecisionType3 *forcesA = forces + cellAStart;
	CUDAPrecisionType3 *forcesB = forces + cellBStart;

	const unsigned char *componentLJCenterIndicesA = componentLJCenterIndices + cellAStart;
	const unsigned char *componentLJCenterIndicesB = componentLJCenterIndices + cellBStart;

	for( int indexA = 0 ; indexA < cellALength ; indexA++ ) {
		for( int indexB = 0 ; indexB < cellBLength ; indexB++ ) {
			const ComponentLJCenterInfo &componentLJCenterInfo = componentLJCenterInfos[ componentLJCenterIndicesA[ indexA ] * numComponentLJCenters + componentLJCenterIndicesB[ indexB ] ];

			calculateInteraction(
					cutOffRadiusSquared, componentLJCenterInfo,
					positionsA[indexA], positionsB[indexB],
					forcesA[indexA], forcesB[indexB],
					totalPotential, totalVirial
				);
		}
	}

	domainValues[cellIndex].x += totalPotential;
	domainValues[cellIndex].y += totalVirial;
	domainValues[neighborIndex].x += totalPotential;
	domainValues[neighborIndex].y += totalVirial;
}

__global__ void Kernel_calculateInnerLJForces(
		const CUDAPrecisionType3 *positions, const unsigned char *componentLJCenterIndices, CUDAPrecisionType3 *forces,
		const ComponentLJCenterInfo *componentLJCenterInfos, const int *componentLJCenterOffsetFromFirst, int numComponentLJCenters,
		const int *cellInfos, float2 *domainValues,
		CUDAPrecisionType cutOffRadiusSquared ) {
	const int cellIndex = blockIdx.x;

	const int cellStart = cellInfos[cellIndex];
	const int cellLength = cellInfos[cellIndex + 1] - cellStart;

	CUDAPrecisionType totalPotential = 0.0f;
	CUDAPrecisionType totalVirial = 0.0f;

	const CUDAPrecisionType3 *cellPositions = positions + cellStart;
	CUDAPrecisionType3 *cellForces = forces + cellStart;
	const unsigned char *componentLJCellCenterIndices = componentLJCenterIndices + cellStart;

	for( int indexA = 0 ; indexA < cellLength ; indexA++ ) {
		// => indexB < indexA always
		// same molecule iff indexA - componentLJCenterOffsetFromFirst[...] <= indexB
		// (and we dont want to calculate LJ for centers from the same molecule!)
		const int maxIndexB = indexA - componentLJCenterOffsetFromFirst[ componentLJCellCenterIndices[ indexA ] ];
		for( int indexB = 0 ; indexB < maxIndexB ; indexB++ ) {
			const ComponentLJCenterInfo &componentLJCenterInfo = componentLJCenterInfos[ componentLJCellCenterIndices[ indexA ] * numComponentLJCenters + componentLJCellCenterIndices[ indexB ] ];

			calculateInteraction(
					cutOffRadiusSquared, componentLJCenterInfo,
					cellPositions[indexA], cellPositions[indexB],
					cellForces[indexA], cellForces[indexB],
					totalPotential, totalVirial
				);
		}
	}

	domainValues[cellIndex].x += totalPotential * 2;
	domainValues[cellIndex].y += totalVirial * 2;
}
