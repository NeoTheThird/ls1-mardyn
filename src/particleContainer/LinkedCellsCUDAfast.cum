#include "cutil_math.h"

// sum over all components of the number of lj centers <= MAX_NUM_TOTAL_LJ_CENTERS
#define MAX_NUM_TOTAL_LJ_CENTERS 4

#define MAX_BLOCK_SIZE 512
#define WARP_SIZE 32
#define NUM_WARPS 4
#define BLOCK_SIZE (WARP_SIZE*NUM_WARPS)

// threadIdx.xy = intraWarpIndex | warpIndex

// = ceil( a / b )
__device__ inline int iceil(int a, int b) {
	return (a+b-1) / b;
}

// = b if a % b = 0, a % b otherwise
__device__ inline int shiftedMod( int a, int b ) {
	int r = a % b;
	return (r > 0) ? r : b;
}

__device__ inline void reducePotentialAndVirial( const int threadIndex, float *potential, float *virial ) {
	// ASSERT: BLOCK_SIZE is power of 2
	for( int power = 2 ; power <= BLOCK_SIZE ; power <<= 1 ) {
		__syncthreads();

		if( (threadIndex & (power-1)) == 0 ) {
			const int neighborIndex = threadIndex + (power >> 1);

			potential[threadIndex] += potential[neighborIndex];
			virial[threadIndex] += virial[neighborIndex];
		}
	}
}

__device__ inline void calculateInteraction(
		const float cutOffRadiusSquared,
		const ComponentLJCenterInfo &componentLJCenterInfo,
		const float3 &positionA, const float3 &positionB,
		float3 &forceA, float3 &forceB,
		float &totalPotential, float &totalVirial
	) {
	const float3 distance = positionB - positionA;
	const float distanceSquared = dot( distance, distance );

	if( distanceSquared >= cutOffRadiusSquared ) {
		return;
	}

	float3 force;
	float potential;
	calculateLennardJones( distance, distanceSquared, componentLJCenterInfo.epsilon, componentLJCenterInfo.sigmaSquared, force, potential );

	totalPotential += potential;
	float virial = dot( force, distance );
	totalVirial += virial;

	forceA += force;
	forceB -= force;
}

enum BlockPairType {
	BPT_UNRELATED,
	BPT_B_NEXT_TO_A, // implies same cell
	BPT_SAME_BLOCK   // implies same cell
};

// componentLJCenterOffsetFromFirst is only used when blockPairType != BPT_UNRELATED
template< BlockPairType blockPairType >
__device__ inline void processBlock(
		const int threadIndex,
		const int numCellsInBlockA,
		const int numCellsInBlockB,
		const float cutOffRadiusSquared,
		const ComponentLJCenterInfo *componentLJCenterInfos,
		const int *componentLJCenterOffsetFromFirst,
		int numComponentLJCenters,
		const float3 &positionA, const float3 *positionsB,
		const unsigned char &componentLJCenterIndexA, const unsigned char *componentLJCenterIndicesB,
		float3 &forceA, float3 *forcesB,
		float &totalPotential, float &totalVirial
		) {
	__shared__ float3 cachedBForces[BLOCK_SIZE];
	__shared__ unsigned char cachedBComponentLJCenterIndices[BLOCK_SIZE];
	__shared__ float3 cachedBPositions[BLOCK_SIZE];

	// load B data into cache
	if( threadIndex < numCellsInBlockB ) {
		cachedBForces[threadIndex] = forcesB[threadIndex];
		cachedBComponentLJCenterIndices[threadIndex] = componentLJCenterIndicesB[threadIndex];
		cachedBPositions[threadIndex] = positionsB[threadIndex];
	}

	// I'm working on WARP_SIZE many data entries at once during processing, so there should be a natural synchronization?
	// TODO: remove this __syncthreads maybe?
	__syncthreads();

	// process block
	const int numShifts = max( numCellsInBlockA, numCellsInBlockB );
	const int numWarps = iceil( numShifts, WARP_SIZE );
	const int numWarpsInBlockB = iceil( numCellsInBlockB, WARP_SIZE );

	const int indexA = threadIndex;

	for( int warpShiftIndex = 0 ; warpShiftIndex < numWarps ; warpShiftIndex++ ) {
		int warpIndexB = (threadIdx.y + warpShiftIndex) % numWarps;

		if( indexA < numCellsInBlockA && warpIndexB < numWarpsInBlockB ) {
			const int numCellShifts = WARP_SIZE;

			for( int cellShiftIndex = 0 ; cellShiftIndex < numCellShifts ; cellShiftIndex++ ) {

				const int indexB = warpIndexB * WARP_SIZE + ((threadIdx.x + cellShiftIndex) % WARP_SIZE);
				if( indexB >= numCellsInBlockB ) {
					continue;
				}

				// if we're not inside the same warp, process all WARP_SIZE * WARP_SIZE pairs inside the warp
				// otherwise only process the lower half
				if( blockPairType == BPT_SAME_BLOCK && indexB >= indexA ) {
					continue;
				}

				// multiple lj center handling code
				if( blockPairType == BPT_SAME_BLOCK ) {
					if( indexA - componentLJCenterOffsetFromFirst[componentLJCenterIndexA] <= indexB ) {
						continue;
					}
				}
				else if( blockPairType == BPT_B_NEXT_TO_A ) {
					if( BLOCK_SIZE + indexA - componentLJCenterOffsetFromFirst[componentLJCenterIndexA] <= indexB ) {
						continue;
					}
				}

				const ComponentLJCenterInfo &componentLJCenterInfo = componentLJCenterInfos[ componentLJCenterIndexA * numComponentLJCenters + cachedBComponentLJCenterIndices[ indexB ] ];
				calculateInteraction( cutOffRadiusSquared, componentLJCenterInfo,
						positionA, cachedBPositions[indexB],
						forceA, cachedBForces[indexB],
						totalPotential, totalVirial
					);
			}
		}
		// sync all warps, so that no two different warps will try to access the same warp data block
		__syncthreads();
	}

	// push B data back
	if( threadIndex < numCellsInBlockB ) {
		forcesB[threadIndex] = cachedBForces[threadIndex];
	}
}

__global__ void Kernel_calculatePairLJForces(
		const float3 *positions, const unsigned char *componentIndices, float3 *forces,
		const ComponentLJCenterInfo *componentLJCenterInfos, int numComponentLJCenters,
		const int *cellInfos, float2 *domainValues,
		int startIndex, int2 dimension, int3 gridOffsets, int neighborOffset,
		float cutOffRadiusSquared ) {
	__shared__ ComponentLJCenterInfo cachedComponentLJCenterInfos[ MAX_NUM_TOTAL_LJ_CENTERS * MAX_NUM_TOTAL_LJ_CENTERS ];

	const int threadIndex = threadIdx.y * WARP_SIZE + threadIdx.x;
	{
		for( int i = threadIndex ; i < numComponentLJCenters * numComponentLJCenters ; i += BLOCK_SIZE ) {
			cachedComponentLJCenterInfos[ i ] = componentLJCenterInfos[ i ];
		}
	}

	int cellIndex = getCellIndex( startIndex, dimension, gridOffsets );
	int neighborIndex = cellIndex + neighborOffset;

	// ensure that cellA_length <= cellB_length (which will use fewer data transfers)
	// (numTransfersA + numTransfersA * numTransfersB) * BLOCK_SIZE
	if( cellInfos[cellIndex].y > cellInfos[neighborIndex].y ) {
		// swap cellIndex and neighborIndex
		cellIndex = neighborIndex;
		neighborIndex -= neighborOffset;
	}

	const int cellAStart = cellInfos[cellIndex];
	const int cellALength = cellInfos[cellIndex + 1] - cellAStart;
	const int cellBStart = cellInfos[neighborIndex];
	const int cellBLength = cellInfos[neighborIndex + 1] - cellBStart;

	__shared__ float totalThreadPotential[BLOCK_SIZE];
	__shared__ float totalThreadVirial[BLOCK_SIZE];

	const int indexA = threadIndex;

	totalThreadPotential[indexA] = 0.0f;
	totalThreadVirial[indexA] = 0.0f;

	// make sure that cachedComponentInfos has been initialized
	__syncthreads();

	const int numBlocksA = iceil( cellALength, BLOCK_SIZE );
	const int numBlocksB = iceil( cellBLength, BLOCK_SIZE );
	for( int blockIndexA = 0 ; blockIndexA < numBlocksA ; blockIndexA++ ) {
		float3 cachedAForce;
		float3 cachedAPosition;
		unsigned char cachedAComponentIndex;

		const int numCellsInBlockA = (blockIndexA < numBlocksA - 1) ? BLOCK_SIZE : shiftedMod( cellALength, BLOCK_SIZE );
		const int blockOffsetA = cellAStart + blockIndexA * BLOCK_SIZE;

		// load A data into (register) cache
		if( indexA < numCellsInBlockA ) {
			const int index = blockOffsetA + indexA;
			cachedAForce = forces[index];
			cachedAPosition = positions[index];
			cachedAComponentIndex = componentIndices[index];
		}

		for( int blockIndexB = 0 ; blockIndexB < numBlocksB ; blockIndexB++ ) {
			const int numCellsInBlockB = (blockIndexB < numBlocksB - 1) ? BLOCK_SIZE : shiftedMod( cellBLength, BLOCK_SIZE );
			const int blockOffsetB = cellBStart + blockIndexB * BLOCK_SIZE;

			processBlock<BPT_UNRELATED>(
					indexA,
					numCellsInBlockA,
					numCellsInBlockB,
					cutOffRadiusSquared,
					cachedComponentLJCenterInfos, NULL, numComponentLJCenters,
					cachedAPosition, positions + blockOffsetB,
					cachedAComponentIndex, componentIndices + blockOffsetB,
					cachedAForce, forces + blockOffsetB,
					totalThreadPotential[indexA], totalThreadVirial[indexA]
				);
		}

		// push A data back
		if( indexA < numCellsInBlockA ) {
			forces[blockOffsetA + indexA] = cachedAForce;
		}
	}

	// reduce the potential and the virial
	// ASSERT: BLOCK_SIZE is power of 2
	reducePotentialAndVirial( threadIndex, totalThreadPotential, totalThreadVirial );

	if( threadIdx.x == 0 && threadIdx.y == 0 ) {
		domainValues[cellIndex].x += totalThreadPotential[0];
		domainValues[cellIndex].y += totalThreadVirial[0];
		domainValues[neighborIndex].x += totalThreadPotential[0];
		domainValues[neighborIndex].y += totalThreadVirial[0];
	}
}

__global__ void Kernel_calculateInnerLJForces(
		const float3 *positions, const unsigned char *componentIndices, float3 *forces,
		const ComponentLJCenterInfo *componentLJCenterInfos, const int *componentLJCenterOffsetFromFirst, int numComponentLJCenters,
		const int *cellInfos, float2 *domainValues,
		float cutOffRadiusSquared ) {
	__shared__ ComponentLJCenterInfo cachedComponentLJCenterInfos[ MAX_NUM_TOTAL_LJ_CENTERS * MAX_NUM_TOTAL_LJ_CENTERS ];

	const int threadIndex = threadIdx.y * WARP_SIZE + threadIdx.x;
	{
		for( int i = threadIndex ; i < numComponentLJCenters * numComponentLJCenters ; i += BLOCK_SIZE ) {
			cachedComponentLJCenterInfos[ i ] = componentLJCenterInfos[ i ];
		}
	}

	const int cellIndex = blockIdx.x;

	const int cellStart = cellInfos[cellIndex];
	const int cellLength = cellInfos[cellIndex + 1] - cellStart;

	__shared__ float totalThreadPotential[BLOCK_SIZE];
	__shared__ float totalThreadVirial[BLOCK_SIZE];

	totalThreadPotential[threadIndex] = 0.0f;
	totalThreadVirial[threadIndex] = 0.0f;

	__syncthreads();

	const int indexA = threadIndex;

	const int numBlocks = iceil( cellLength, BLOCK_SIZE );
	for( int blockIndexA = 0 ; blockIndexA < numBlocks ; blockIndexA++ ) {
		float3 cachedAForce;
		float3 cachedAPosition;
		unsigned char cachedAComponentIndex;

		const int numCellsInBlockA = (blockIndexA < numBlocks - 1) ? BLOCK_SIZE : shiftedMod( cellLength, BLOCK_SIZE );
		const int blockOffsetA = cellStart + blockIndexA * BLOCK_SIZE;

		// load A data into (register) cache
		if( indexA < numCellsInBlockA ) {
			const int index = blockOffsetA + threadIndex;
			cachedAForce = make_float3( 0.0f );

			cachedAPosition = positions[index];
			cachedAComponentIndex = componentIndices[index];
		}

		processBlock<BPT_SAME_BLOCK>(
				threadIndex,
				numCellsInBlockA,
				numCellsInBlockA,
				cutOffRadiusSquared,
				cachedComponentLJCenterInfos, componentLJCenterOffsetFromFirst, numComponentLJCenters,
				cachedAPosition, positions + blockOffsetA,
				cachedAComponentIndex, componentIndices + blockOffsetA,
				cachedAForce, forces + blockOffsetA,
				totalThreadPotential[indexA], totalThreadVirial[indexA]
			);

		for( int blockIndexB = 0 ; blockIndexB < blockIndexA - 1; blockIndexB++ ) {
			// blockIndexB < blockIndexA - 1  < numBlocks - 1 implies numCellsInBlock = BLOCK_SIZE
			const int numCellsInBlockB = BLOCK_SIZE;
			const int blockOffsetB = cellStart + blockIndexB * BLOCK_SIZE;

			processBlock<BPT_UNRELATED>(
					threadIndex,
					numCellsInBlockA,
					numCellsInBlockB,
					cutOffRadiusSquared,
					cachedComponentLJCenterInfos, NULL, numComponentLJCenters,
					cachedAPosition, positions + blockOffsetB,
					cachedAComponentIndex, componentIndices + blockOffsetB,
					cachedAForce, forces + blockOffsetB,
					totalThreadPotential[indexA], totalThreadVirial[indexA]
				);
		}
		// treat the last B block differently (BPT_B_NEXT_TO_A)
		if( blockIndexA > 0) {
			const int blockIndexB = blockIndexA - 1;
			const int numCellsInBlockB = shiftedMod( cellLength, BLOCK_SIZE );
			const int blockOffsetB = cellStart + blockIndexB * BLOCK_SIZE;

			processBlock<BPT_B_NEXT_TO_A>(
					threadIndex,
					numCellsInBlockA,
					numCellsInBlockB,
					cutOffRadiusSquared,
					cachedComponentLJCenterInfos, componentLJCenterOffsetFromFirst, numComponentLJCenters,
					cachedAPosition, positions + blockOffsetB,
					cachedAComponentIndex, componentIndices + blockOffsetB,
					cachedAForce, forces + blockOffsetB,
					totalThreadPotential[indexA], totalThreadVirial[indexA]
				);
		}

		// push A data back
		if( threadIndex < numCellsInBlockA ) {
			forces[blockOffsetA + threadIndex] += cachedAForce;
		}
	}

	/// reduce the potential and the virial
	// ASSERT: BLOCK_SIZE is power of 2
	reducePotentialAndVirial( threadIndex, totalThreadPotential, totalThreadVirial );

	if( threadIdx.x == 0 && threadIdx.y == 0 ) {
		domainValues[cellIndex].x += totalThreadPotential[0] * 2;
		domainValues[cellIndex].y += totalThreadVirial[0] * 2;
	}
}
